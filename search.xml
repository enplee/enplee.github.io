<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021-05-09周赛题解</title>
    <url>/2021/05/09/2021-05-09%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目一：人口最多的年份"><a href="#题目一：人口最多的年份" class="headerlink" title="题目一：人口最多的年份"></a>题目一：人口最多的年份</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;maximum-population-year&#x2F;</span><br><span class="line">## 参考 https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;living-people-lcci&#x2F; 存活人数</span><br></pre></td></tr></table></figure>

<h4 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h4><p>观察数据范围，直接暴力法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumPopulation</span><span class="params">(self, logs)</span>:</span></span><br><span class="line">        res,year = <span class="number">0</span>,<span class="number">1950</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1950</span>,<span class="number">2051</span>):</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> per <span class="keyword">in</span> logs:</span><br><span class="line">                <span class="keyword">if</span> i &gt;= per[<span class="number">0</span>] <span class="keyword">and</span> i&lt; per[<span class="number">1</span>]: temp +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> temp &gt; res:</span><br><span class="line">                res = temp</span><br><span class="line">                year = i</span><br><span class="line">        <span class="keyword">return</span> year</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="方法二：-查分数组"><a href="#方法二：-查分数组" class="headerlink" title="方法二： 查分数组"></a>方法二： 查分数组</h4><p>bore-died区间的计数加一，可以使用<strong>差分数组</strong>做区间修改。</p>
<ul>
<li>时间复杂度 O(n)</li>
<li>空间复杂度 O(D)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumPopulation</span><span class="params">(logs [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">101</span>)</span><br><span class="line">	<span class="keyword">for</span> _,per := <span class="keyword">range</span> logs &#123;</span><br><span class="line">		arr[per[<span class="number">0</span>]<span class="number">-1950</span>]+=<span class="number">1</span></span><br><span class="line">		arr[per[<span class="number">1</span>]<span class="number">-1950</span>]-=<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(arr);i++ &#123;</span><br><span class="line">		arr[i] += arr[i<span class="number">-1</span>]</span><br><span class="line">		res = max(res,arr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目二：下标对中距离最大值"><a href="#题目二：下标对中距离最大值" class="headerlink" title="题目二：下标对中距离最大值"></a>题目二：下标对中距离最大值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;maximum-distance-between-a-pair-of-values&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="方法一：-双指针"><a href="#方法一：-双指针" class="headerlink" title="方法一： 双指针"></a>方法一： 双指针</h4><p>非递增数据，双指针进行求解</p>
<ul>
<li>时间复杂度 O(n)</li>
<li>空间复杂度 O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        n,m = len(nums1),len(nums2)</span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n <span class="keyword">and</span> j&lt;m:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &lt;= nums2[j]:</span><br><span class="line">                <span class="keyword">while</span> j&lt;m <span class="keyword">and</span> nums1[i]&lt;=nums2[j]:</span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                res = max(res,j-i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">elif</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="题目三：子数组最小乘积的最大值"><a href="#题目三：子数组最小乘积的最大值" class="headerlink" title="题目三：子数组最小乘积的最大值"></a>题目三：子数组最小乘积的最大值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;maximum-subarray-min-product&#x2F;</span><br><span class="line">### 参考题目：</span><br><span class="line">https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;largest-rectangle-in-histogram&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="方法一：单调队列-前缀和"><a href="#方法一：单调队列-前缀和" class="headerlink" title="方法一：单调队列+前缀和"></a>方法一：单调队列+前缀和</h4><p>子数组最小乘积：min(array[])*sum(array[])</p>
<p>数组中的数为正整数，子数组乘积的最大值分布在：以数组中每一个数字为最小值的最长数组中。</p>
<p>所有最长数组的max就是最大值。</p>
<p>数组中求以某个元素为最小值的最长子数组，就是找出数组中最左和最右第一个大于该元素的位置。</p>
<p>单调栈–&gt;元素入栈时，已知左侧；出栈时候，已知右侧。如果出现相同，根据题意需要两次单调栈。</p>
<ul>
<li>时间复杂度 O(n)</li>
<li>空间复杂度 O(n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="number">1000000000</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumMinProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            sum[i] = sum[i-<span class="number">1</span>]+ nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] l = <span class="keyword">new</span> <span class="keyword">int</span>[n],r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(r,n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peekLast()] &gt; nums[i]) &#123;</span><br><span class="line">                Integer top = stack.pollLast();</span><br><span class="line">                r[top] = i-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peekLast()] &gt; nums[i]) &#123;</span><br><span class="line">                Integer top = stack.pollLast();</span><br><span class="line">                l[top] = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Double res = <span class="number">0</span>D;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            res = Math.max(res,nums[i]*(sum[r[i]+<span class="number">1</span>]-sum[l[i]]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (res%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="题目四：有向图的最大颜色值"><a href="#题目四：有向图的最大颜色值" class="headerlink" title="题目四：有向图的最大颜色值"></a>题目四：有向图的最大颜色值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;largest-color-value-in-a-directed-graph&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="方法一-：拓扑排序-DP"><a href="#方法一-：拓扑排序-DP" class="headerlink" title="方法一 ：拓扑排序+DP"></a>方法一 ：拓扑排序+DP</h4><p>题目首先要求判断有向图是否有环，手段有：DFS，拓扑排序。如果拓扑序列&lt;n，存在环。</p>
<p>对于有向无环图，假设一种颜色，可以按照拓扑顺序进行递归求解或者反拓扑顺序进行DP</p>
<p>在反拓扑序列进行DP时：DP[i] = max(DP[v] in edges[v])+ colors[i]==color ? 1:0</p>
<ul>
<li>时间复杂度 O(26*n)</li>
<li>空间复杂度 O(n) </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestPathValue</span><span class="params">(self, colors, edges)</span>:</span></span><br><span class="line">        mm,n = &#123;&#125;,len(colors)</span><br><span class="line">        inDegree = [<span class="number">0</span>]*n</span><br><span class="line">        <span class="keyword">for</span> a,b <span class="keyword">in</span> edges:</span><br><span class="line">            inDegree[b]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> edges: mm[a] = set()</span><br><span class="line">            mm[a].add(b)</span><br><span class="line">        q = Queue(maxsize=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> inDegree[i]==<span class="number">0</span>: q.put(i)</span><br><span class="line">        tp = []</span><br><span class="line">        <span class="keyword">while</span> len(q)&gt;<span class="number">0</span>:</span><br><span class="line">            top = q.get()</span><br><span class="line">            tp.append(top)</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> mm[top]:</span><br><span class="line">                inDegree[v]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inDegree[v]==<span class="number">0</span>: tp.append(v)</span><br><span class="line">        <span class="keyword">if</span> len(tp)!=n : <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> color <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            dp = [<span class="number">0</span>]*n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                u = tp[i]</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> mm[u]:</span><br><span class="line">                    dp[u] = max(dp[u],dp[v])</span><br><span class="line">                <span class="keyword">if</span> (ord(colors[u])-ord(<span class="string">'a'</span>)==color): dp[u]+=<span class="number">1</span></span><br><span class="line">                res = max(res,dp[u])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之线程顺序打印</title>
    <url>/2020/11/28/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<h3 id="问题：实现T1-T2两个线程交替打印A1B2C3……"><a href="#问题：实现T1-T2两个线程交替打印A1B2C3……" class="headerlink" title="问题：实现T1,T2两个线程交替打印A1B2C3……"></a>问题：实现T1,T2两个线程交替打印A1B2C3……</h3><p>交替打印的实现，依赖于线程之间的有序阻塞和唤醒。可以用到的有：Synchronized的wait&amp;notify,LockSupport的park&amp;unpark,reentrenlock的condition以及CAS。</p>
<h4 id="解法一：使用wait-amp-notify"><a href="#解法一：使用wait-amp-notify" class="headerlink" title="解法一：使用wait&amp;notify"></a>解法一：使用wait&amp;notify</h4><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Syn_wait_notify</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用wait()和notify() 必须加锁synchronized才能使用</span></span><br><span class="line">    <span class="comment">// wait() 会释放锁 for执行结束要notify使最后一个wait线程被唤醒 才能顺序结束</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                    System.out.println((<span class="keyword">char</span>)(i+<span class="string">'A'</span>));</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        o.notify();</span><br><span class="line">                        o.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                o.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)&#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        o.notify();</span><br><span class="line">                        o.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notify();</span><br><span class="line">                &#125;</span><br><span class="line">                o.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二-LockSupport-park-amp-unpark"><a href="#解法二-LockSupport-park-amp-unpark" class="headerlink" title="解法二 LockSupport: park&amp;unpark"></a>解法二 LockSupport: park&amp;unpark</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock_lockSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread t1 = <span class="keyword">null</span>,t2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)(<span class="string">'A'</span>+i));</span><br><span class="line">                LockSupport.unpark(t2);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>);</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)&#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                LockSupport.unpark(t1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法三-condition"><a href="#解法三-condition" class="headerlink" title="解法三 condition"></a>解法三 condition</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock_reenternLock_condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Condition 本质上是不同的阻塞队列</span></span><br><span class="line">        <span class="comment">// condition1.await() 将当前线程加入到condition1的阻塞队列中</span></span><br><span class="line">        <span class="comment">// condition2.await() 将condition2阻塞队列中的线程唤醒</span></span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition1 = lock.newCondition();</span><br><span class="line">        Condition condition2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                    System.out.println((<span class="keyword">char</span>)(i+<span class="string">'A'</span>));</span><br><span class="line">                    condition2.signal();</span><br><span class="line">                    condition1.await();</span><br><span class="line">                &#125;</span><br><span class="line">                condition2.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    condition1.signal();<span class="comment">//唤醒condition1等待队列中的线程</span></span><br><span class="line">                    condition2.await();<span class="comment">//放到condition2这个等待队列</span></span><br><span class="line">                &#125;</span><br><span class="line">                condition1.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法四：CAS-大道至简"><a href="#解法四：CAS-大道至简" class="headerlink" title="解法四：CAS 大道至简"></a>解法四：CAS 大道至简</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cas_enum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> ReadyToRun &#123;T1,T2&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> ReadyToRun r = ReadyToRun.T1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">while</span> (r!=ReadyToRun.T1) &#123;&#125;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)(<span class="string">'A'</span>+i));</span><br><span class="line">                r = ReadyToRun.T2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">while</span> (r!=ReadyToRun.T2) &#123;&#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                r = ReadyToRun.T1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>【模型压缩】CVPR2020-Filter Grafting for Deep Neural Networks</title>
    <url>/2020/09/23/%E3%80%90%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E3%80%91CVPR2020-Filter%20Grafting%20for%20Deep%20Neural%20Networks/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>本文提出了一种新的学习范式，即滤波器嫁接，旨在提高深度神经网络的表示能力。动机是DNNs具有不重要的(无效的)过滤器(例如，l1norm接近于0)。这些过滤器限制了DNNs的潜力，因为它们被认为对网络的影响很小。当过滤剪枝删除这些无效过滤器的效率考虑，过滤嫁接重新激活他们从准确性提高的观点。通过将外部信息(权重)嫁接到无效的过滤器中来处理激活。为了更好地执行嫁接过程，我们开发了一个基于熵的标准来衡量过滤器的信息，以及一个自适应加权策略来平衡网络间的嫁接信息。接枝操作后，与未接触状态相比，网络的无效滤波器非常少，使模型具有更大的表示能力。我们还对分类和识别任务进行了大量的实验，以证明我们的方法的优越性。例如，在CIFAR-100数据集上，嫁接的MobileNetV2比未嫁接的MobileNetV2性能好约7%。</p>
<p><a href="https://github.com/fxmeng/filter-grafting.git" target="_blank" rel="noopener">https://github.com/fxmeng/filter-grafting.git</a>.</p>
<a id="more"></a>

<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>自从Krizhevsky et al.在2012年ImageNet竞赛中取得突破以来，研究人员在探索DNNs的各种建筑方面取得了重大进展。在计算机视觉、语音识别和语言处理等领域，DNNs逐渐成为非常流行和强大的模型。</p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Filter%20Grafting%20for%20Deep%20Neural%20Networks1.png" alt="Filter Grafting for Deep Neural Networks1"></p>
<p>然而，最近的研究表明，DNNs有无效(不重要)过滤器[9]。这些滤波器被认为对输出精度有很小的影响。删除某些过滤器可以加速DNNs的推断，而不会对性能造成很大影响。这一发现激发了许多研究如何确定哪些滤波器是不重要的[13]，以及如何在可容忍的性能下降情况下有效地去除滤波器的工作[29,19]。然而，目前还不清楚是否直接放弃这种过滤器和组件是否是最好的选择。如果这些传统的无效过滤器在某种意义上确实有用呢?同样的情况也发生在像boosting这样的集成学习中，当单个弱分类器性能较差时，它们的组合和再训练可能会打开通往最佳性能的大门。此外，考虑到有多个网络，网络能否从其他网络学习还不清楚。<strong>在本文中，我们研究了在一个网络中通过引入外部信息来重新激活无效过滤器的可能性。</strong></p>
<p>我们通过提出一种新颖的滤波嫁接方案来实现这一点，如图1所示。过滤器嫁接在意义上不同于过滤器剪枝，我们重新激活过滤器分配新的权重，它保持每一层中的层和过滤器的数量相同。由于网络中有更多有效的滤波器参与信息处理，因此嫁接后的网络具有更高的表示能力。</p>
<p>滤波器嫁接的一个关键步骤是选择合适的信息源(即，我们应该从哪里嫁接信息)。在本文中，我们对这一问题进行了深入的研究，并提出应该从外部(其他网络)嫁接信息，而不是从内部(自网络)嫁接信息。一般来说，我们可以并行地训练几个网络。在特定时期的训练中，我们将一个网络的有意义的滤波器嫁接到另一个网络的无效滤波器中。通过嫁接，每个网络可以从其他网络学习外部信息。详情请参阅第3节。本文主要有三个贡献:</p>
<ul>
<li>我们提出了一种新的学习范式，称为DNNs的滤波器嫁接。嫁接可以在不改变网络结构的情况下，重新激活失效的过滤器，提高DNNs的潜力。</li>
<li>为进一步提高滤波接枝方法的性能，<strong>提出了一种基于熵的准则和自适应加权策略。</strong></li>
<li>我们在分类和识别任务上进行了广泛的实验，表明嫁接可以显著提高DNNS的性能。例如，嫁接的MobileNetV2达到了CIFAR-100上的78.32%的准确率，这比没有嫁接的MobileNetV2高出约7%。</li>
</ul>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><p><strong>Filter Pruning.</strong>过滤器修剪的目的是去除无效的过滤器，加速网络推理。[9]首先利用l1范数准则对不重要的滤波器进行修剪。从那以后，更多的标准出现来衡量过滤器的重要性。[29]利用光谱聚类来决定需要去除哪个滤波器。[19]提出了一种固有的数据驱动方法，它利用主成分分析(PCA)来指定应该保留的能量比例。[21]将子空间聚类应用于特征图，消除卷积滤波器中的冗余。<strong>相比放弃无效的过滤器，过滤嫁接打算激活它们。</strong></p>
<p>值得注意的是，即使嫁接过滤器的动机与嫁接相反，嫁接仍然涉及选择一个适当的标准来决定哪些过滤器是不重要的。<strong>因此，不同的标准修剪容易适用于嫁接。</strong></p>
<p><strong>Distillation and Mutual Learning.</strong>嫁接可能需要同时训练多个网络。因此这个过程类似于蒸馏[6]和互学习[25]。接枝和蒸馏的区别在于，蒸馏是一个“两阶段”的过程。首先，我们需要培养一个大模型(教师)，然后用训练好的模型去教一个小模型(学生)。虽然嫁接是一个“单阶段”的过程，但我们在训练过程中嫁接权重。互学习和嫁接的区别在于，互学习需要一个互损失来监督每个网络进行学习，不能很好地推广到多个网络。而嫁接不需要监督损失，当我们在训练过程中加入更多的网络时，其表现会好得多。同时，我们将权值在每个epoch而不是每个迭代进行嫁接，从而大大降低了网络间的通信成本。</p>
<p><strong>RePr.</strong> RePr[14]与我们的工作类似，我们考虑在过滤器级别上改进网络。然而，使用RePr的动机是网络过滤器捕获的特性中存在不必要的重叠。首先对重叠滤波器进行修剪以训练子网络，然后恢复修剪后的滤波器并重新训练整个网络。从这个意义上讲，RePr是一个多阶段的训练算法。相比之下，滤波器嫁接的动机是l1norm越小的滤波器对网络输出贡献越少。因此，每个方法操作的过滤器是不同的。此外，嫁接是一种更有效的单阶段训练算法。为了更好地说明嫁接与上述学习类型的区别。我们在表1中画了一个表。从表1可以看出，滤波器嫁接是一种单阶段学习方法，不改变网络结构，也不需要监督损失。</p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Filter%20Grafting%20for%20Deep%20Neural%20Networks2.png" alt="Filter Grafting for Deep Neural Networks2"></p>
<h3 id="Filter-Grafting"><a href="#Filter-Grafting" class="headerlink" title="Filter Grafting"></a>Filter Grafting</h3><h4 id="Information-Source-for-Grafting"><a href="#Information-Source-for-Grafting" class="headerlink" title="Information Source for Grafting"></a>Information Source for Grafting</h4><p><strong>Noise as Scions</strong> 一种简单的方法是将高斯噪声嫁接到无效滤波器中，因为高斯噪声通常用于DNNs的权值初始化[8,3]。在嫁接之前，无效滤波器的l1norm较小，对输出的影响较小。但嫁接后，无效滤波器l1范数增大，对DNNs的影响开始增大。</p>
<p>*<em>Internal Filters as Scions *</em>我们将其他滤波器(l1norm较大)的权值加入到无效滤波器(l1norm较小)中，而不是加入随机噪声。嫁接是在单个网络内进行的。具体来说，对于每一层，我们根据l1norm对过滤器进行排序，并设置一个阈值。对于l1norm小于right的过滤器，我们将这些过滤器视为无效的。然后我们将第i个最大的滤波器的权值嫁接到第i个最小的滤波器中。</p>
<p>由于无效过滤器具有具有更大l1规范的新权重，因此可以激活它们以对输出产生更大的影响。但由于权值是在自网络内部嫁接的，因此该方法并没有给网络带来新的信息。我们通过语言信息理论对其进行了进一步的评价。为了简化证明过程，我们在网络的某一层中处理两个滤波器(见定理1，证明可以在补充材料中找到)。从定理m1中，选择内部过滤器作为scions不会带来新的信息。第4.1节中的实验也与我们的分析一致。</p>
<p><strong>External Filters as Scions</strong> 针对在单一网络中添加随机噪声和权值的缺点，我们从其他网络中选择外部滤波器作为scions。具体来说，我们可以并行训练两个网络，分别表示为m1和M2。在一定时期的训练中，我们将有效滤波器m1的权重嫁接到无效滤波器M2中。与3.1.2节中的嫁接过程相比，我们做了两处修改:</p>
<ul>
<li>嫁接是在层而不是滤波层进行的，这意味着我们将M1中某一层的所有过滤器的权重嫁接到M2的同一层中(也就是M2到M1中，反向)。由于两个网络用不同的权值初始化，无效滤波器的位置在统计上是不同的，仅将信息嫁接到某一层的部分滤波器中可能会破坏层的一致性(详见补充资料中的分析和实验结果)。通过嫁接，两个网络的无效滤波器可以相互学习对方的信息。</li>
<li>在进行嫁接时，对其内在信息和外在信息进行加权。</li>
</ul>
<h4 id="Criterions-for-Calculating-Information-of-Filters-and-Layers"><a href="#Criterions-for-Calculating-Information-of-Filters-and-Layers" class="headerlink" title="Criterions for Calculating Information of Filters and Layers"></a>Criterions for Calculating Information of Filters and Layers</h4><p><strong>L1norm</strong> l1norm准则在很多研究中被广泛使用[9,23,22]。但最近的研究表明，更小的正常重要性标准并不总是正确的。一种特殊情况是0-1有规则的过滤器比所有1个过滤器更好。[5]还指出，使用这个更小的标准不那么重要的标准有一些先决条件。否则，修剪可能会损害有效的过滤器。</p>
<p><strong>Entropy</strong> 而l1norm准则只关注滤波器权值的绝对值，我们更关注权值的变化。l1范数准则的一个问题是l1范数忽略了权重的变化。假设一个滤波器的权值Wi,j∈RNi×K×ksatisfy  Wi,j(n, k1, k2) = a，对于每个n∈{1，…， Ni}和k1, k2∈{1，…， K}， Wi,  j中每个单个值将是相同的。因此，当使用Wi,j对输入进行卷积运算时，即使a很大，输入的每一部分对输出的贡献也是相等的。因此，滤波器不能区分输入的哪个部分更重要。基于以上分析，我们选择测量权重的变化。我们假设Wi,jis的每个值都是从随机变量X的分布中取样，并使用熵来测量分布。假设分布满足P(X  = a) =  1，则Wi、j中各单值相同，熵为0。虽然计算连续分布的熵值比较困难，但我们遵循[17,1]的策略。我们首先将连续分布转换为离散分布。具体地说，我们将值的范围分成m个不同的箱子并计算每个箱子的概率。最后，可以计算出变量的熵。</p>
<h3 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h3><h4 id="Selecting-Useful-Information-Source"><a href="#Selecting-Useful-Information-Source" class="headerlink" title="Selecting Useful Information Source"></a>Selecting Useful Information Source</h4><p>我们在第3节中提出了三种获取scions的方法，并在表2中的CIFAR-10和CIFAR-100数据集上实验检验了这三种方法。Vanilla  DNN训练不嫁接为基线。所有的方法都使用MobileNetV2作为基础模型。为了进行公平的比较，为每个方法部署了相同的超参数:mini-batch size(256)、optimizer(SGD)、initial learning rate(0.1)、momentum(0.9)、weight decay(0.0005)、epochs (200)、learning rate decay(每60  epoch  0.1)。这里的“外部”包括并行地训练两个网络。在实践中，我们发现“外部”方法中的每个网络的性能都非常接近。因此，在剩余的时间里，我们总是记录第一个网络的性能。</p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Filter%20Grafting%20for%20Deep%20Neural%20Networks3.png" alt="Filter Grafting for Deep Neural Networks3"></p>
<h4 id="Comparison-of-L1norm-amp-Entropy-Criterions"><a href="#Comparison-of-L1norm-amp-Entropy-Criterions" class="headerlink" title="Comparison of L1norm &amp; Entropy Criterions"></a>Comparison of L1norm &amp; Entropy Criterions</h4><p>在第3.2节中，我们提出了测量滤波器固有信息的两个标准。在这一部分中，我们对基于l1normbased嫁接和基于熵的嫁接在CIFAR-10和CIFAR-100数据集上进行了定量评价。结果如表3所示。采用两个网络进行嫁接，具有相同的模型结构和训练超参数。从表3可以看出，在每个模型和数据集的设置上，基于熵的嫁接都优于基于l1norm1的嫁接.</p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Filter%20Grafting%20for%20Deep%20Neural%20Networks4.png" alt="Filter Grafting for Deep Neural Networks4"></p>
<h4 id="Evaluation-of-Training-Diversity-in-Grafting"><a href="#Evaluation-of-Training-Diversity-in-Grafting" class="headerlink" title="Evaluation of Training Diversity in Grafting"></a>Evaluation of Training Diversity in Grafting</h4><p>我们发现当我们增加两个网络的训练多样性时，网络的性能得到了提高。<strong>由于嫁接是关于在模型之间转移权重，如果外部信息(权重)有更多的变化，网络可以更好地学习</strong>。为了实现这一点，我们可以多样化超参数设置(在我们的例子中采样顺序和学习率)，看看这些因素是如何影响嫁接性能的。结果如表4所示。在不同的LR情况下，为每个模型设置了具有不同初始学习率的余弦退火LR调度(这确保了在每一步，每个模型的学习率是不同的)。我们发现，采样顺序和学习率带来的权值变化丰富了嫁接信息，从而促进了模型更好地学习。在剩下的，当执行嫁接时，所有网络在数据加载器和学习速率方面的不同焓变参数。</p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Filter%20Grafting%20for%20Deep%20Neural%20Networks4.png" alt="Filter Grafting for Deep Neural Networks5"></p>
<h4 id="Comparing-Grafting-with-Other-Methods"><a href="#Comparing-Grafting-with-Other-Methods" class="headerlink" title="Comparing Grafting with Other Methods"></a>Comparing Grafting with Other Methods</h4><p>我们在表1中详细研究了嫁接和其他学习方法的区别。在这一部分中，我们在表5的CIFAR10和CIFAR-100数据集上实验比较了与其他方法的嫁接。为了进行公平的比较，“蒸馏”、“相互学习”和“过滤嫁接”都涉及到训练两个网络。蒸馏和嫁接的区别在于蒸馏是一个两阶段的训练过程。在进行蒸馏时，我们首先训练一个网络直到收敛，然后我们利用网络，作为教师，提取知识到学生网络。为了与嫁接公平比较，教师和学生的网络结构是相同的，这与[25]中的设置是一致的。而光栅的训练是一次性完成的，不需要再训练过程。互学习和嫁接的区别在于，互学习对两个网络进行了另一个强大的监督损失训练，网络之间的通信成本也很高。在使用互学习方法时，应仔细选择互监督损失和主损失的系数。而嫁接时，转移重量不需要监督。利用熵对权重进行嫁接，自适应地计算权重系数，效率更高。从表5可以看出，在所有的学习方法中，滤波嫁接的效果最好。</p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Filter%20Grafting%20for%20Deep%20Neural%20Networks6.png" alt="Filter Grafting for Deep Neural Networks6"></p>
<h4 id="Grafting-with-Multiple-Networks"><a href="#Grafting-with-Multiple-Networks" class="headerlink" title="Grafting with Multiple Networks"></a>Grafting with Multiple Networks</h4><p>滤波器接枝算法的强大之处在于，通过在接枝算法中加入更多的网络，可以大大提高算法的性能。我们在表6中检验了多项式嫁接的效果。随着网络数量的增加，性能会越来越好。例如，6个模型的性能可以比基线高出7%，这是一个很大的改进。</p>
<p>原因是MobileNetV2是基于深度可分卷积的，他的过滤器可能学习不足的知识滤波器嫁接可以帮助滤波器从其他网络中学习互补知识，极大地提高了网络的潜力。值得注意的是，6个模型的嫁接效果优于6个模型的组合。但与ensemble不同的是，grafting只维护了一个用于测试的网络。然而，当我们将模型数量增加到8时，嫁接算法的性能有所下降。我们认为原因可能是网络从外界接收了过多的信息，影响了其学习的自我信息。如何很好地解释这一现象是一项有趣的未来工作。</p>
<h4 id="Grafting-on-ImageNet"><a href="#Grafting-on-ImageNet" class="headerlink" title="Grafting on ImageNet"></a>Grafting on ImageNet</h4><p>为了测试在较大数据集上进行嫁接的性能，我们还对ImageNet进行了嫁接验证，ImageNet是一个拥有超过1400万张图像的图像分类数据集。我们将移植与ResNet18和ResNet34模型上的基线进行比较。基准超参数的设置与ImageNet1的官方PyTorch设置一致:小批量大小(256)、初始学习速率(0.1)、学习速率衰减(每30个epoch  0.1)、动量(0.9)、重量衰减(0.0001)、epoch数量(90)和优化器(SGD)。为了增加训练的多样性，我们对两个网络在进行嫁接时使用了不同的学习速率和不同的数据加载器。其他超参数的设置与基线一致。结果如表7所示。</p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Filter%20Grafting%20for%20Deep%20Neural%20Networks7.png" alt="Filter Grafting for Deep Neural Networks7"></p>
<h3 id="Conclusion-and-Discussion"><a href="#Conclusion-and-Discussion" class="headerlink" title="Conclusion and Discussion"></a>Conclusion and Discussion</h3><p>在这项工作中，提出了一种新的学习范式，称为“滤波器嫁接”。我们认为有效应用滤波器嫁接算法有两个关键:1)如何选择合适的准则来计算DNNs中滤波器的固有信息。2)如何平衡网络之间的信息系数。针对这两个问题，我们提出了基于熵的判据和自适应加权策略来提高网络的性能。但这不是唯一的解决方案。为了进一步改进该算法，还可以发展其他的标准或方法。启发性地，有一些未来的方向需要考虑:1)在嫁接算法中如何在网络数量更多的情况下提高网络的性能;2)如何在不同网络结构的多个网络上应用嫁接。</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Filter Graft</tag>
      </tags>
  </entry>
  <entry>
    <title>【模型压缩】CVPR2020-HRank:Filter Pruning using High-Rank Feature Map</title>
    <url>/2020/09/22/%E3%80%90%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E3%80%91CVPR2020-HRankFilter%20Pruning%20using%20High-Rank%20Feature%20Map/</url>
    <content><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>神经网络剪枝为深度神经网络在资源受限设备上的应用提供了广阔的前景。然而，现有的剪枝方法由于缺乏对非显著网络成分的理论指导，在剪枝设计中存在训练效率低、人工成本高的问题。本文通过对高秩特征图的研究，提出了一种新的滤波剪枝方法。<strong>我们的HRank的灵感来自于这样一个发现，即由单个过滤器生成的多个特征图的平均秩总是相同的，而不考虑接收到的CNNs图像batch的数量。在此基础上，本文提出了一种用数学方法对低秩特征图进行滤波的方法。我们的剪枝背后的原则是，低秩特征图包含的信息较少，因此剪枝的结果可以很容易地复制</strong>。此外，我们还通过实验证明了高秩特征图的权值包含了更多的重要信息，即使不更新一部分，对模型性能的影响也很小。在不引入任何额外约束的情况下，HRank在计算和参数减少方面比现有技术有了显著的改进，并且具有相似的准确性。</p>
<p><a href="https://github.com/lmbxmu/HRank" target="_blank" rel="noopener">https://github.com/lmbxmu/HRank</a></p>
<a id="more"></a>

<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>卷积神经网络（CNN）在计算机视觉应用方面取得了巨大成功，如分类，检测 和分割。然而，它们对计算能力和内存的高要求阻止将大多数最先进的 CNN 部署在边缘设备（如智能手机或可穿戴设备）中。虽然在设计新的硬件和/或硬件特定的CNN加速框架（如TensorRT）方面已经取得了良好的进展，但是是通过在acc方面的妥协来实现降低FLOPs和CNN的大小。流行的技术包括：filter压缩，参数量化和网络修剪。</p>
<p>其中，网络修剪已显示出广阔的应用前景。典型的工作或者修剪Weight矩阵来获得sparse(稀疏)权重矩阵(weight pruning);或者从网络中删除整个过滤器(filter pruning)。除了网络压缩，权重修剪方法也可以实现加速在专用软件或硬件 .但是，它们在通用硬件或 BLAS 库上的应用上受限。相比之下，滤镜修剪方法没有此限制，因为整个filter都已删除。本文重点介绍filter修剪以实现模型压缩（参数减少）和加速度（FLOPs的减少），旨在为计算能力较低的设备提供多功能解决方案。</p>
<p>filter修剪的核心在于filter的选择，用较低的准确率换取高压缩率。基于filter评价函数的设计，对filter进行了实证分类基于过滤器评估函数的设计，我们根据经验将过滤器修剪分为两组，如下所述。</p>
<h5 id="Property-Importance：根据-CNN-的内在属性对筛选器进行修剪。"><a href="#Property-Importance：根据-CNN-的内在属性对筛选器进行修剪。" class="headerlink" title="Property Importance：根据 CNN 的内在属性对筛选器进行修剪。"></a>Property Importance：根据 CNN 的内在属性对筛选器进行修剪。</h5><p>这些修剪方法不会修改网络训练损失。修剪后，通过微调提高模型性能。在这些方法中，Hu et al.利用大型网络中输出的稀疏性来移除具有高百分比零激活的filter。基于l1范数的修剪方法假设参数或特征的范数小，那么具有更少的信息，应该首先被修剪。Molchanov et al.考虑了一阶梯度来评估filter的重要性。Hu et al.计算layers中的几何中位数，并修剪最接近此的滤镜。大多数filter评估功能的设计都是ad-hoc–为了某个特定目的，所建立起来的.这带来了低时间复杂度的优点，但也限制了加速度和压缩比。</p>
<p><strong>Adaptive Importance</strong>：不同于基于属性重要性的方法，另一个方向将修剪要求嵌入到网络训练损失中，并采用联合修剪优化来生成自适应修剪决策。</p>
<p>Liu et al.批处理规范化层的缩放因子施加了空间约束，允许将具有较低缩放因子的通道标识为无极性。Huang et al.引入了一个新的缩放因子参数（也称为掩码），以学习稀疏结构修剪，其中删除与缩放因子为零的筛选器。与基于属性重要性的filter prune相比，自适应重要性方法通常由于联合优化而产生更好的压缩和加速度结果。然而，由于损失的变化，所需的再培训步骤在机器时间和人力方面都是沉重的，我们要求另一轮超参数调整。对于某些方法<em>，例如</em>，基于掩码的方案，修改后的损耗甚至需要专门的优化器，这会影响基于自适应重要性的方法的灵活性和易用性。</p>
<p>总体而言，到目前为止，过滤器修剪仍然是一个开放的问题。一方面，我们追求更高的压缩/加速度比，另一方面，我们受到重型机器时间和人力的限制（特别是Adaptive Importance为基础的方法）。<strong>我们认为这些问题的核心是缺乏有关filter重要性和冗余的实际/理论指导。</strong>在这篇论文中，我们提出了一种有效和高效的滤镜修剪方法：探索CNN每层特征图的High Rank。我们所提出的 HRank 为基于属性重要性的筛选器修剪器提供指导。它消除了引入额外的辅助约束或重新训练模型的需要，从而简化了修剪的复杂性。此外，与现有的基于属性重要性的方法相比，HRank在加速和压缩方面也有显著改进，比最先进的基于重要性的自适应方法取得更好的效果。实施高等级特征图背后的动机来自经验和定量的观察。我们发现，无论CNN看到多少数据，单个filter生成的特征图的平均排名总是相同的。这表明，只使用一小部分输入图像就可以精确的估计DNN的特征图排名。基于这一理念，我们从数学上证明，较低等级的特征图对准确性的贡献较小。因此，可以首先删除生成这些要素映射的筛选器。我们在CIFAR-10和ImageNet上对诸多模型进行了测试。结果表明，HRank优于现有filter修剪方法，包括基于属性重要性的方法和最先进的自适应重要性模型。另外的试验表明，即使我们在修剪后微调期间冻结了带有高等级特征图的部分filter，模型仍保留高精度，这验证了我们的假设。主要贡献为：</p>
<ul>
<li>在广泛统计验证后，我们通过经验证明，单个filter生成的特征图的平均排名几乎保持不变。据我们所知，这是第一次报道这一观察。</li>
</ul>
<ul>
<li>我们从数学上证明，具有较低等级特征图的filter信息较少，因此对保持精度不太重要，可以先删除。对于高等级要素地图，情况正好相反。<br>•  广泛的实验证明了HRank在各种最先进的模型压缩和加速度方面的有效性和高效性。</li>
</ul>
<h4 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h4><h5 id="Filter-Pruning"><a href="#Filter-Pruning" class="headerlink" title="Filter Pruning"></a>Filter Pruning</h5><p>与修剪重量矩阵的权重修剪相反，滤镜修剪会根据特定指标删除整个筛选器。滤波修剪不仅大大降低了存储使用，而且降低了在线推理的计算成本。如第 sec 中所讨论的。1、滤波修剪可分为两类：属性重要性方法和自适应重要性方法。基于属性重要性的筛选器修剪旨在利用CNN的内在属性（例如l1范数，第一梯度），然后使用它们作为区分不太重要的过滤器的标准。</p>
<p><strong>Low-rank Decomposition</strong></p>
<p>神经网络往往被过度参数化，这表明每个图层中的参数可以准确地从一个小子集中恢复。受此启发，低等级分解已成为网络压缩的替代方案。它通过将权重矩阵表示为两个较小矩阵的低级乘积来近似卷积操作。与修剪不同，它旨在降低网络的计算成本，而不是更改原始筛选器的数量。虽然低等级分解有利于CNN的压缩和加速，但通常在高压缩比下，精度会有较大的损失。</p>
<h5 id="Discussions"><a href="#Discussions" class="headerlink" title="Discussions"></a>Discussions</h5><p>与权重W修剪相比，filter修剪在降低模型复杂性方面更为有利。此外，无需专门的软件或硬件支持，其结构化修剪可以轻松集成到高效BLAS库中。然而，现有的filter修剪方法受到低效的加速和压缩（基于属性重要性的filter修剪）或机器和人工成本（自适应导入基于filter修剪），如Sec所讨论的。1.这两个问题给在资源有限的设备上部署深度 CNN 带来了根本性的挑战。我们把这种两难处境归因于缺少有关filter的实用/理论指导。我们关注要素图的排名，并在理论和实验上分析其有效性。<strong>请注意，我们的方法与低级分解方法是正交的。</strong>我们的目标是修剪过滤器生成低等级的图图，而不是分解过滤器。请注意，低等级方法可以集成到我们的模型中（<em>例如，</em>分解完全连接的层），以实现更高的压缩和加速率。</p>
<h4 id="The-Proposed-Method"><a href="#The-Proposed-Method" class="headerlink" title="The Proposed Method"></a>The Proposed Method</h4><p>具体见论文</p>
<h4 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h4><p><strong>Experimental Settings</strong></p>
<p><strong>Datasets and Baselines.</strong>数据集和基线。为了证明我们在降低模型复杂性方面的效率，我们在小型和大型数据集（CIFAR-10 和ImageNet）上进行了实验。我们研究主流CNN模型上不同算法的性能，包括结构简单结构的VGGNet，具有初始模块的GoogLeNet，带残余块的 ResNet和密集块的DenseNet。对于所有benchMark 和体系结构，<strong>我们随机采样 500 张图像，以估计每个要素图的平均排名</strong>。</p>
<p><strong>Evaluation Protocols</strong>.我们采用广泛使用的协议，即<em>参数数</em>和所需的浮点操作（表示为FLOPs），以评估模型大小和计算要求。为了评估任务特定功能，我们提供修剪模型的前 1 精度和CIFAR-10 上的修剪率（表示为 PR），以及 ImageNet 上修剪模型的top1和top5精度。</p>
<p><strong>Conﬁgurations.</strong>我们使用 PyTorch  来实施建议的 HRank 方法。我们使用随机梯度下降算法（SGD）解决优化问题，初始学习速率为0.01,批号、重量衰减和动量设置为 128,0.0005 和 0<em>.</em>9，分别。对于每一层，我们在修剪后重新训练网络30个纪元,训练更多的时代时，可以观察到更高的准确性。然而，它需要更多的培训时间。</p>
<h4 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h4><p>本文提出了一种名为HRank的新颖滤镜修剪方法，它通过确定特征图的排名来确定滤镜的相对重要性。为此，我们通过经验证明，单个筛选器生成的要素贴图的平均排名始终相同。然后，我们用数学方法证明，该代低等级要素图不太重要，应先删除，反之亦然，实验也验证了这一点。此外，我们建议冻结部分滤波器，以生成高等级特征图，以进一步降低微调成本，对模型性能几乎没有影响。对各种现代CN的广泛实验证明了HRank在降低计算复杂性和模型大小方面的有效性。在未来的工作中，我们将对为什么单个filter生成的特征图的平均排名始终相同进行理论分析。</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Filter Prune</tag>
      </tags>
  </entry>
  <entry>
    <title>【模型压缩】CVPR2020-Towards Efficient Model Compression via Learned Global Ranking</title>
    <url>/2020/10/04/%E3%80%90%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E3%80%91CVPR2020-Towards%20Efficient%20Model%20Compression%20via%20Learned%20Global%20Ranking/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3>]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Filter Prune</tag>
      </tags>
  </entry>
  <entry>
    <title>【模型压缩】CVPR2020-Filter Pruning via Geometric Median</title>
    <url>/2020/10/14/%E3%80%90%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E3%80%91CVPR2020-Filter%20Pruning%20via%20Geometric%20Median/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>以前的工作使用“<strong>较小范数不太重要</strong>”的标准来修剪卷积神经网络中具有较小范数值的滤波器。本文分析了这种基于范数的准则，指出其有效性取决于两个不总是满足的要求:<strong>(1)滤波器的范数偏差应该很大；(2)滤波器的最小范数应该很小。</strong>为了解决这个问题，我们提出了一种新的滤波剪枝方法，即基于几何中值(FPGM)的滤波剪枝，来压缩模型而不考虑这两个要求。与以前的方法不同，FPGM通过修剪冗余过滤器来压缩CNN模型，而不是那些“相对不太重要”的过滤器。当应用于两个图像分类基准时，我们的方法验证了它的有用性和优势。值得注意的是，在CIF  AR-10上，FPGM在ResNet-110上减少了52%以上的浮点运算，相对精度提高了2.69%。此外，在ILSVRC2012上，FPGM在ResNet101上减少了超过42%的浮点运算，而没有前5名的精度下降，这提高了最先进的水平。</p>
<p>GitHub:<br><a href="https://github.com/he-y/filter-pruning-geometric-median" target="_blank" rel="noopener">https://github.com/he-y/filter-pruning-geometric-median</a></p>
<a id="more"></a>

<h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h4><p>深层神经网络更深更广的体系结构带来了计算机视觉任务的卓越性能[6，26，45]。然而，它们也导致了极其昂贵的计算成本，并使得在移动设备上部署模型变得困难，如果不是不可能的话。即使是最新的高效率架构，如剩余连接[12]或初始模块[34]，也有数百万个参数需要数十亿次浮点运算(FLOPs)  [15]。</p>
<p>因此，有必要获得计算成本相对较低但精度较高的深层CNN模型。</p>
<p>![CVPR2020-Filter Pruning via Geometric Median](D:\blogs\source_posts\CVPR\CVPR2020-Filter Pruning via Geometric Median.png)</p>
<p>修剪的最新发展可分为两类，即权重修剪[11，1]和过滤修剪[21，39]。权重修剪直接删除过滤器中的权重值，这可能会导致非结构化稀疏性。这种不规则的结构使得利用高效的基本线性代数子程序库变得困难[25]。相比之下，过滤器修剪直接丢弃整个选定的过滤器，并留下具有规则结构的模型。因此，为了加速网络和减小模型尺寸，过滤器修剪是更优选的。</p>
<p>目前的实践[21，38，15]通过遵循“较小范数不太重要”的标准来执行过滤器修剪，该标准认为具有较小范数的过滤器由于其不太重要而可以被安全地修剪。如图1(a)的右上角所示，在计算模型中过滤器的规范之后，使用预先指定的阈值T来选择其规范小于它的过滤器。</p>
<p>然而，如图1(b)所示，利用这个“较小的规范不太重要”的标准有两个先决条件。第一，过滤规范的偏差应该是显著的。这一要求使得阈值T的搜索空间足够宽，因此分离那些需要修剪的过滤器将是一项简单的任务。第二，那些可以删减的滤波器的范数应该任意小，即接近于零；换句话说，具有较小规范的过滤器被期望对网络作出绝对小的贡献，而不是相对小但肯定大的贡献。令人满意地满足这两个要求时的理想范数分布如图1中的蓝色曲线所示。不幸的是，根据我们的分析和实验观察，这并不总是正确的。</p>
<p>为了解决上述问题，我们提出了一种新的滤波修剪方法，称为几何中值滤波修剪(FPGM)。与以前修剪贡献相对较小的过滤器的方法不同，FPGM选择贡献最可替换的过滤器。具体来说，我们计算同一层内滤波器的几何中值(GM)  [8]。根据遗传算法的特点，它附近的滤波器可以用剩余的滤波器来表示。因此，修剪这些过滤器不会对模型性能产生实质性的负面影响。请注意，FPGM没有使用基于规范的标准来选择要修剪的过滤器，这意味着即使在未能满足基于规范的标准的要求时，其性能也不会恶化。</p>
<p><strong>我们有三个贡献:</strong></p>
<p>(1)我们分析了以前工作中使用的基于规范的准则，它删减了相对不太重要的过滤器。我们详细阐述了导致其局限性的两个基本要求；(2)我们提出FPGM剪枝包含冗余信息的最可替换的过滤器，当基于规范的准则失败时仍能获得良好的性能；(3)对两个基准的广泛试验证明了FPGM的有效性和效率。</p>
<h4 id="2-Related-Works"><a href="#2-Related-Works" class="headerlink" title="2. Related Works"></a>2. Related Works</h4><p>以往大多数关于加速CNNs的工作大致可以分为四类，即矩阵分解[42，35]、低精度权重[44，43，32]、知识提取[17，19]和剪枝。基于剪枝的方法旨在去除神经网络中不必要的连接[11，21，24]。本质上，权重修剪总是导致非结构化模型，这使得部署高效的BLAS库变得困难，而过滤器修剪不仅减少了设备上的存储使用，而且降低了计算成本以加速推理。我们可以根据训练数据是否用于确定被修剪的过滤器，将过滤器修剪方法大致分为两类，即数据相关的和数据无关的过滤器修剪。与数据无关的方法比与数据相关的方法更有效，因为训练数据的利用是计算消耗。</p>
<p><strong>Weight Pruning.</strong>。最近的许多工作[11，10，9，36，1，15，41，4]集中在修剪过滤器的细粒度权重。例如，[11]提出了一种迭代方法来丢弃其值低于预定阈值的小权重。[1]将修剪公式化为在满足修剪成本条件的同时找到最小化损失的权重的优化问题。</p>
<p><strong>Data Dependent Filter Pruning</strong> 一些过滤器修剪方法[23，25，16，27，7，33，39，37，46，14，18，22]需要利用训练数据来确定被修剪的过滤器。[25]采用下一层的统计信息来指导过滤器的选择。[7]旨在通过最小化训练集样本激活的重构误差来获得分解。[33]提出了一种固有的数据驱动方法，该方法使用主成分分析来指定应该保留的能量比例。[37]将子空间聚类应用于特征映射，以消除卷积滤波器中的冗余。</p>
<p><strong>Data Independent Filter Pruning.</strong>与我们的工作同时，已经探索了一些数据独立的过滤器修剪策略[21，15，38，47]。[21]使用一个“1”标准来删减不重要的过滤器。[15]建议用“2范数”标准选择过滤器，并以软方式删减那些选择的过滤器。[38]提出通过加强批量标准化层的缩放参数的稀疏性来修剪模型。[47]在过滤器上使用光谱聚类来选择不重要的过滤器。</p>
<p>据我们所知，只有一个先前的工作重新考虑了较小的规范不太重要的标准[38]。我们希望强调我们与这种方法相比的优势如下:(1)  [38]更注意在批处理规范化操作符中对缩放参数实施稀疏性，这对于没有批处理规范化的结构是不友好的。我们的方法不受这一限制。(2)选择修剪通道后，[38]需要微调以减少性能下降。然而，我们的方法结合了修剪操作和正常的训练程序。因此，不需要额外的微调。(3)[38]需要计算比例因子的梯度；因此，大量的计算成本是不可避免的，而我们的方法可以在不计算比例因子梯度的情况下加速神经网络。</p>
<h4 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a>4. Experiments</h4><p>我们根据两个基准评估FPGM的单分支网络(VGGNet [31])和多分支网络(ResNet):CIFAR-10[20]和ILSVRC-2012  [29]3。CIFAR-10 [20]数据集包含10个不同类别的60，000幅32 ×  32彩色图像，其中包括50，000幅训练图像和10，000幅测试图像。ILSVRC2012  [29]是包含128万个训练图像和1000个类的50k个验证图像的大规模数据集。</p>
<p><strong>4.1. Experimental Settings</strong></p>
<p>Training setting。在CIFAR-10上，参数设置与[13]相同，训练计划与[40]相同。在ILSVRC-2012实验中，我们使用了与[12，13]相同的默认参数设置。ILSVRC-2012的数据论证策略与PyTorch  [28]官方示例相同。我们分析了从零开始和预先训练的模型之间的区别。为了从头开始修剪模型，我们使用正常的训练时间表，而没有额外的微调过程。对于预训练模型的剪枝，我们将学习率降低到原始学习率的十分之一。为了对修剪模型和预训练模型进行公平的比较，我们使用相同的训练时期来训练/微调网络。以前的工作[21]可能使用较少的时期来微调修剪后的模型，但它收敛得太早，即使使用更多的时期，其精度也不能提高，这可以在第4.2节中显示。</p>
<p>Pruning setting。在过滤器修剪步骤中，我们简单地同时以相同的修剪率修剪所有加权层，这与[15]相同。因此只需要一个超参数Pi=  P就可以平衡加速度和精度。修剪操作在每个训练周期结束时进行。与以前的工作[21]不同，灵敏度分析在FPGM并不是实现良好性能的必要条件，这将在后面的章节中演示。</p>
<p>![CVPR2020-Filter Pruning via Geometric Median (2)](D:\blogs\source_posts\CVPR\CVPR2020-Filter Pruning via Geometric Median (2).png)</p>
<p>除了FPGM唯一准则外，我们还使用了FPGM和以前基于规范的方法[15]的混合，以表明FPGM可以作为以前方法的补充。FPGM唯一标准表示为“FPGM混合标准”，FPGM和基于规范的标准相结合的标准表示为“混合标准”。“FPGM-仅40%”表示该层的40%过滤器仅由FPGM选择，而“FPGM-混合40%”表示该层的30%过滤器由基于规范的标准选择[15]，其余10%过滤器由FPGM选择。我们将FPGM与以前的加速算法进行了比较，例如MIL  [5]，PFEC [21]，CP [16]，ThiNet [25]，SFP [15]，NISP  [39]，重新思考[38]。毫不奇怪，我们的FPGM方法达到了最先进的结果。</p>
<p><strong>4.2. Single-Branch Network Pruning</strong></p>
<p>CIFAR-10上的VGGNet。由于[21]的训练设置不公开，我们重新实施了修剪程序，并获得了与原始论文相似的结果。表3和表4分别显示了修剪预训练模型和擦除模型的结果。毫不奇怪，FPGM在这两种情况下都取得了比[21]更好的表现。</p>
<p><strong>4.3. Multiple-Branch Network Pruning</strong></p>
<p>CIFAR-10上的ResNet。对于CIFAR-10数据集，我们在ResNet-20、32、56和110上用两种不同的修剪率测试了我们的FPGM:30%和40%。如表1所示，我们的FPGM实现了最先进的性能。例如，没有微调的MIL  [5]将ResNet-32的加速比提高了31.2%，精度下降了1.59%，但我们没有微调的FPGM实现了53.2%的加速比，精度甚至提高了0.19%。与SFP  [15]相比，当修剪ResNet-56的52.6%的浮点运算时，我们的FPGM只有0.66%的精度下降，远远小于SFP [15]  (1.33%)。对于修剪预先训练的ResNet-110，我们的方法获得了高得多(52.3% vs . s .  38.6%)的加速比，性能提高了0.16%，而PFEC [21]损害了加速比较低的性能。这些结果表明，FPGM可以产生一个性能相当甚至更好的压缩模型。</p>
<p>关于ILSVRC-2012的ResNet。对于ILSVRC-2012数据集，我们在ResNet-18、34、50和101上测试了我们的FPGM，剪枝率分别为30%和40%。与[15]相同，为了简化，我们不修剪投影快捷键。</p>
<h4 id="5-Conclusion-and-Future-Work"><a href="#5-Conclusion-and-Future-Work" class="headerlink" title="5. Conclusion and Future Work"></a>5. Conclusion and Future Work</h4><p>在本文中，我们详细阐述了基于规范的过滤器修剪标准的基本要求，并指出其局限性。为了解决这个问题，我们提出了一种基于几何中值的新的滤波修剪策略，命名为FPGM，以加速深层神经网络。与以前的标准不同，FPGM明确考虑了过滤器之间的相互关系。由于这一点，FPGM在几个基准中实现了最先进的性能。未来，我们计划研究如何将FPGM与其他加速算法(如矩阵分解和低精度权重)相结合，将性能推向更高的阶段。</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Filter Graft</tag>
      </tags>
  </entry>
  <entry>
    <title>序/Introduction</title>
    <url>/2020/05/11/%E5%BA%8F-Introduction/</url>
    <content><![CDATA[<center><font size="4">木舟远远地越过这片海域</font><br></center> 
<center><font size="4">大大的船帆满满地承受着风势</font><br></center>  
<center><font size="4">直面前往新世界</font><br></center>  
<center><font color="#dd0000"> </font><br></center>


<center>Rewrite CANOE</center> 



<center><font color="#dd0000"> </font><br></center>
<center><font color="#dd0000"> </font><br></center>
<center><font size="6">你好 欢迎来到 Enplee's Blog!</font><br></center>                  




<a id="more"></a>]]></content>
      <categories>
        <category>序</category>
      </categories>
      <tags>
        <tag>Introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>多级反馈队列调度算法</title>
    <url>/2020/08/06/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="操作系统之多级反馈队列调度算法"><a href="#操作系统之多级反馈队列调度算法" class="headerlink" title="操作系统之多级反馈队列调度算法"></a>操作系统之多级反馈队列调度算法</h3><h6 id="多级反馈队列调度-MLFQ-算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。多级反馈队列调度算法是目前操作系统调度算法中被公认的一种较好的调度算法。它可以满足各种类型进程的需要，既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。"><a href="#多级反馈队列调度-MLFQ-算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。多级反馈队列调度算法是目前操作系统调度算法中被公认的一种较好的调度算法。它可以满足各种类型进程的需要，既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。" class="headerlink" title="多级反馈队列调度(MLFQ)算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。多级反馈队列调度算法是目前操作系统调度算法中被公认的一种较好的调度算法。它可以满足各种类型进程的需要，既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。"></a>多级反馈队列调度(MLFQ)算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。多级反馈队列调度算法是目前操作系统调度算法中被公认的一种较好的调度算法。它可以满足各种类型进程的需要，既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。</h6><a id="more"></a>

<h5 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 设有N个队列（Q1,Q2....QN），其中各个队列对于处理机的优先级不同,即位于各个队列中的作业(进程)的优先级也是不一样的。</span><br><span class="line">   一般来说，优先级Priority(Q1) &gt; Priority(Q2) &gt; ... &gt; Priority(QN)。</span><br><span class="line">   位于Q1中的任何一个作业(进程)都要比Q2中的任何一个作业(进程)相对于CPU的优先级要高，依次类推其它的队列。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 对于优先级最低的队列(QN)，作业调度遵循时间片轮转法。位于队列QN中有M个作业，运行时间是通过QN这个队列所设定的时间片来确定的；</span><br><span class="line">   对于其他队列，遵循的是先来先服务算法,同时每一进程分配一定的时间片，若时间片运行完时进程未结束，则进入下一优先级队列的末尾。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 各个队列的时间片是随着优先级的增加而减少的，也就是说，优先级越高的队列中它的时间片就越短。</span><br><span class="line">   同时，为了便于那些超大作业的完成，最后一个队列QN(优先级最低的队列)的时间片一般很大。</span><br></pre></td></tr></table></figure>

<h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><ol>
<li>进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。</li>
<li>首先调度优先级高的队列中的进程。若Q1中没有调度的进程，则调度次优先级队列中的进程。当且仅当高优先级队列中没有调度的进程是，才调度次优先级。</li>
<li>对于同一个进程中的进程，采用先来先服务(FCFS)分配固定时间片调度(除了最后一个对列)。分配的时间片大小取决去当前队列。如果当前作业在固定时间片内未完成，进入下一级队列，直至完成。</li>
<li>在最后一个对列的进程，采用时间片轮转调度方式调度。</li>
<li>当低优先级队列中的进程正在运行时，有新的作业到达，此时须立即把正在运行的进程放回当前队列的队尾，然后把处理机分给高优先级进程(抢占式)。或者等待当前进程执行结束，重新回到高优先级队列中(非抢占式)。</li>
</ol>
<h5 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h5><p>​    多级反馈队列调度算法既能最小化交互工作的<strong>响应时间</strong>，又能减少对工作长度的先验知识，从而<strong>最小化周转时间</strong>。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>System</tag>
      </tags>
  </entry>
  <entry>
    <title>【模型压缩】CVPR2020-Learning Filter Pruning Criteria for Deep Convolutional Neural Networks Acceleration</title>
    <url>/2020/09/23/%E3%80%90%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E3%80%91CVPR2020-Learning%20Filter%20Pruning%20Criteria%20for%20Deep%20Convolutional%20Neural%20Networks%20Acceleration/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>滤波器修剪(filter prune)在神经网络的压缩和加速中得到了广泛的应用。现有的方法通常利用预定义的修剪标准,例如ℓp-norm(范数),修剪不重要的filter。这些方法有两个主要的限制。<strong>首先，流行的方法没有考虑不同层次的filter分布的多样性。为了将粗级特征提取到细级特征，不同层的滤波器具有不同的分布。</strong>因此，对不同的功能层使用相同的修剪标准是不合适的。<strong>其次，主流的逐层剪枝方法独立、顺序地处理每一层，没有考虑到网络中的所有层协同做出最终预测。</strong>在本文中，我们提出了学习filter剪枝准则(LFPC)来解决上述问题。具体地说，<strong>我们开发了一个可微的剪枝标准采样器。该采样器是可学习的，并通过采样准则得到的剪枝网络的验证损失来优化</strong>。通过这种方式，我们可以为不同的功能层自适应地选择合适的剪枝标准。此外，LFPC在评价采样准则时，同时综合考虑了各层的贡献。在三种图像分类基准上的实验验证了我们的方法。</p>
<a id="more"></a>

<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>卷积神经网络在各种计算机视觉研究应用中取得了显著进展。然而，这些手工设计的架构，如VGG ，  ResNet，通常都有巨大的模型尺寸和繁重的计算成本。很难将这些模型部署到实时响应的场景中。近年来，对模型压缩和加速的研究逐渐兴起。修剪策略由于其有效性，在前人的研究中备受关注。剪枝的最新进展可以分为两类，即权重剪枝[14]和过滤剪枝[27]。滤波器剪枝可以使剪枝模型更加结构化，实现实际的加速剪枝。现有的过滤器修剪方法遵循三个阶段准则。(1)训练:在目标数据集上训练一个大模型。(2)剪枝:根据特定的准则，对预训练模型中的不重要滤波器进行剪枝。(3)微调(再训练):对修剪后的模型进行再训练，恢复原始性能。在这三个阶段中，选择合适的修剪标准是关键因素。</p>
<p>但是，之前的作品有一些缺点，可能不是真实应用场景的最佳选择。首先，先前的工作人为的指定一个剪枝标准，<strong>并对不同的层使用相同的剪枝标准</strong>。如[52]所示，不同的层具有不同的filter分布和变量方法。较低的层倾向于提取粗糙的层次特征，如线、点和曲线，而较高的层倾向于提取精细的层次特征，如常见的对象和形状。在这种情况下，为所有功能层固定一个修剪标准可能不合适。换句话说，最好能并发评估所有层的过滤器重要性。</p>
<p>我们提出了学习过滤器剪枝准则(LFPC)来解决这些问题。LFPC的核心部件是可区分准则采样器(DCS)，其目的是针对不同的层采样不同的准则。这个采样器，因为它是可微的，可以有效地更新，以找到合适的样本。首先，DCS为所有层初始化一个可学习的标准概率。对于每一层，DCS根据滤波器和准则概率进行准则转发，得到准则特征图。在对各层进行准则转发后，得到准则丢失，并将其作为监督信号加以利用。可以通过对准则损失进行反向传播来更新准则概率分布，从而更好地适应网络的滤波分布。与以往的逐层修剪工作不同，我们的LFPC可以通过准则丢失来同时考虑所有的层次和所有的修剪准则。DCS训练完成后，优化后的criteria服务器作为网络的剪枝标准，如图1所示。剪枝后，对剪枝后的模型进行一次微调，得到一个高效、准确的模型。</p>
<p>所作的贡献总结如下：</p>
<ul>
<li>提出了一种有效的学习框架——<strong>学习过滤器剪枝准则(LFPC)。这个框架可以学习为每个功能层选择最合适的修剪标准。此外，所提出的可微准则采样器(DCS)可以端到端训练，并在剪枝时同时考虑所有层</strong>。据我们所知，这是该研究方向的第一项工作。</li>
<li>在三个基准测试上的实验证明了我们的LFPC的有效性。值得注意的是，它将ResNet110的速度提高了两倍，与CIFAR-10相比，它的相对精度甚至提高了0.31%。此外，我们在ResNet-50上减少了60%以上的失败，只有0.83%的top5精度损失。</li>
</ul>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><p>以往的修剪工作可分为权重修剪和过滤修剪。权值修剪侧重于修剪过滤器的细粒度权值，从而导致模型的非结构化稀疏性。相比之下，通过对DNN进行过滤剪枝可以实现结构稀疏性，因此剪枝模型可以充分利用高效的基本线性代数子程序库(BLAS)，实现更好的加速。考虑到如何评估过滤器的重要性，我们可以将过滤器修剪方法大致分为两类，即基于权重的标准和基于活动的标准。此外，修剪算法还可以根据修剪频率进行大致分组，即“贪婪修剪”和“一次性修剪”。我们将在Tab中演示分类。</p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Learning%20Filter%20Pruning%20Criteria1.png" alt="Learning Filter Pruning Criteria1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不同类别的过滤剪枝算法。“W”和“A”表示基于权重和基于活动的标准。“O”和“G”表示一次性的贪婪修剪。</span><br></pre></td></tr></table></figure>

<p><strong>基于权重的标准</strong>。一些方法利用过滤器的权重来确定过滤器的重要性。[18]利用ℓ2-norm标准选择过滤器并删除这些选中的过滤器。[51]引入批处理归一化(BN)层标度参数的稀疏性来对网络进行裁剪。[20]声称，靠近几何中值的滤波器应该被修剪。<strong>所有的工作对不同的层使用相同的修剪标准，没有考虑到不同的层有不同的功能和不同的过滤器分布。</strong></p>
<p><strong>基于激活的标准</strong>。一些研究利用训练数据和过滤器激活来确定修剪过滤器。[45]采用主成分分析(PCA)方法来指定网络的哪一部分需要保留。[36]建议使用来自下一层的信息来指导过滤器的选择。[10]将训练集样本激活的重构误差最小化，并应用奇异值分解(SVD)得到滤波器的分解。[49]研究不同特征图之间的线性关系，消除卷积滤波器中的冗余。</p>
<p><strong>贪婪的一次性修剪</strong>。贪婪剪枝，意味着修剪和再训练需要操作多次。贪婪剪枝虽然有利于提高剪枝的精度，但它需要大量的计算资源，且耗时较长。相比之下，一次热修剪[20,27]将网络修剪一次，再进行一次训练以恢复精度。它比贪婪剪枝更有效，但需要仔细的剪枝标准选择。在本文中，我们主要研究一次性剪枝。其他修剪和搜索方法。一些作品利用强化学习[19,23]或元学习[33]进行剪枝。相比之下，我们专注于通过差分采样器学习不同层次的适当剪枝标准。[4]提出向心SGD使多个滤波器收敛到一个单一点。[54]是一种全局剪枝方法，但剪枝神经元的重要性没有得到传播。我们的学习标准的思想与神经结构搜索(NAS)的工作[58,31]和自动增强[3]有一些相似之处，不同的是我们的搜索空间是修剪标准，而不是网络结构或增强策略。</p>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Learning%20Filter%20Pruning%20Criteria5.png" alt="Learning Filter Pruning Criteria5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标准在层内向前。不同颜色的框表示不同的修剪标准。</span><br><span class="line">首先，我们根据不同的标准来评估过滤器的重要性。</span><br><span class="line">其次，我们对具有小重要性分数的过滤器进行修剪，得到四种不同概率的修剪层。</span><br><span class="line">然后输出的feature map是剪枝层的四个feature map的对齐加权和。</span><br></pre></td></tr></table></figure>



<h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><h4 id="Experimental-Setting"><a href="#Experimental-Setting" class="headerlink" title="Experimental Setting"></a>Experimental Setting</h4><p><strong>数据集</strong>。在本节中，我们在三个基准数据集，CIFAR-10,  CIFAR-100和ILSVRC-2012上验证了我们的加速方法的有效性。CIFAR-10数据集包含5万幅训练图像和1万幅测试图像，共6万幅32×32彩色图像，分布在10个不同的类中。CIFAR-100有100个类，图像数量与CIFAR-10相同。ILSVRC-2012包含128万张训练图像和1000个类的50k张验证图像。</p>
<p><strong>结构设置</strong>。由于ResNet具有捷径结构，现有文献认为ResNet的冗余比VGGNet少，加速ResNet比加速VGGNet困难。因此，我们重点修剪具有挑战性的ResNet。</p>
<p><strong>正常训练设置</strong>。对于CIFAR10和CIFAR-100的ResNet，我们使用与[55]相同的训练计划。在CIFAR实验中，我们将每个设置运行3次，并报告“mean±std”。在ILSVRC2012实验中，我们使用与[15,16]相同的默认参数设置，使用与官方PyTorch[40]示例相同的数据论证策略。</p>
<p><strong>修剪设置</strong>。在对DCS进行训练后，我们使用优化的准则对网络进行修剪，并使用完整的训练集对网络进行微调。我们分析了修剪scratch模型与预训练模型的区别。为了修剪scratch模型，我们使用常规的训练计划，而不需要额外的微调。为了对预先训练好的模型进行裁剪，我们将学习率降低到原始学习率的十分之一。为了进行公平的比较，我们使用与[20]相同的基线模型进行修剪。在再训练过程中，我们使用余弦调度器[35,8]来获得一个稳定的结果。每一层的剪枝率采样方式与DCS1相同，可以自动自适应搜索比率[8]。</p>
<h4 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h4><p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Learning%20Filter%20Pruning%20Criteria2.png" alt="Learning Filter Pruning Criteria2"></p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Learning%20Filter%20Pruning%20Criteria3.png" alt="Learning Filter Pruning Criteria3"></p>
<p><img src="http://qhi3etyt1.hn-bkt.clouddn.com/Learning%20Filter%20Pruning%20Criteria4.png" alt="Learning Filter Pruning Criteria4"></p>
<h3 id="Conclusion-and-Future-Work"><a href="#Conclusion-and-Future-Work" class="headerlink" title="Conclusion and Future Work"></a>Conclusion and Future Work</h3><p>在这篇文章中，我们提出了一个新的学习过滤器剪枝准则(LFPC)框架用于深度CNNs加速。与现有的方法不同，LFPC明确考虑了层之间的差异，并自适应地为不同的层选择一组合适的标准。为了有效地学习准则，我们利用Gumbel-softmax使准则可微化。<strong>在几个基准测试中，LFPC用最先进的方法取得了可比较的性能。在未来，我们可以考虑在LFPC中使用更多的准则，并结合其他加速算法，如矩阵分解[28]，进一步提高性能。此外，将该方法应用于最近的小型Cnn(MobileNet)也有一定的意义。</strong></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Filter Prune</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记之位运算</title>
    <url>/2020/11/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h3 id="算法笔记之位运算"><a href="#算法笔记之位运算" class="headerlink" title="算法笔记之位运算"></a>算法笔记之位运算</h3><h4 id="Brian-Kernighan-算法"><a href="#Brian-Kernighan-算法" class="headerlink" title="Brian Kernighan 算法"></a>Brian Kernighan 算法</h4><p>内容：通过n&amp;(n-1), 清除二进制n的最右边1</p>
<p>原理：n-1就是找到n最右边的1然后变为0，借1，同时最右边1的右边一定全是0，那么&amp;操作之后，最右边的1变为0.</p>
<p>应用：Bk算法可用来求两个数的二进制公共前缀。</p>
<a id="more"></a>

<h4 id="题目·数字范围按位与"><a href="#题目·数字范围按位与" class="headerlink" title="题目·数字范围按位与"></a>题目·<a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">数字范围按位与</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定范围[m,n],返回此范围内所有书的按位与结果。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解法一 寻找公共前缀</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m!=n)&#123;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        move++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m&lt;&lt;move;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用BK算法 寻找最长公共前缀</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m&lt;n)&#123;</span><br><span class="line">        n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目·汉明距离"><a href="#题目·汉明距离" class="headerlink" title="题目·汉明距离"></a>题目·<a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">汉明距离</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x,y的汉明距离指的是二进制不同位置的数目，计算x,y的汉明距离</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异或之后 求1个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> axr = x^y,dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((axr&amp;(<span class="number">1</span>&lt;&lt;i))!=<span class="number">0</span>) dist++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用BK消除1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> axr = x^y;</span><br><span class="line">    <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (axr!=<span class="number">0</span>)&#123;</span><br><span class="line">        dist++;</span><br><span class="line">        axr &amp;= (axr-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>byte</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记之Manacher算法</title>
    <url>/2020/08/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8BManacher%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="算法笔记之Manacher算法"><a href="#算法笔记之Manacher算法" class="headerlink" title="算法笔记之Manacher算法"></a>算法笔记之Manacher算法</h2><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题描述：最长回文子串问题</span><br><span class="line">	给定一个字符串，求它的最长回文子串长度。</span><br><span class="line">示例：</span><br><span class="line">	s &#x3D; abbabbac  最长回文子串为：abbabba</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="解法一：中心扩展法"><a href="#解法一：中心扩展法" class="headerlink" title="解法一：中心扩展法"></a>解法一：中心扩展法</h4><p>​    任何一个回文串一定关于某个中心字符对称的，偶数长度的字符串对称中心是长度为2的字符，例如<strong>aabbaa</strong>中的对称中心是bb，奇数长度的字符串对称中心是长度为1的字符，例如<strong>acbca</strong>的对称中心是b。根据这个特性，针对任何一个字符串，可以对所有可能的对称中心向外拓展，例如：<strong>aabbaa</strong>的长度为1的对称中心a,a,b,b,a,a,长度为2的对称中心aa,bb,aa。当拓展是，只要保证最外层两个字符相等，那么就是一个回文串。对于长度为n的字符串，对称中心有2n-1个，每个对称中心扩展比较的复杂度是On,所以此算法的时间复杂度是O(n^2)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：Manacher算法"><a href="#解法二：Manacher算法" class="headerlink" title="解法二：Manacher算法"></a>解法二：Manacher算法</h4><p>​    中心扩展法虽然很直观，但是时间复杂度是O(n^2),这对于长字符串是不可以接受的。于是，就要介绍文章的主角：Manacher(马拉车)算法。马拉车算法通过巧妙的手法，实现了On的复杂度，鬼斧神工。</p>
<p>​    <strong>解法一</strong>存在着部分缺陷：</p>
<ol>
<li><p>回文串长度的奇偶性带来了两种不同的对称中心，需要不同的处理。</p>
</li>
<li><p>在进行中心扩展时，做了很多重复的访问。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如： S &#x3D; &quot;ababa&quot;</span><br><span class="line">	  i &#x3D;  01234</span><br><span class="line">当：i&#x3D;1,i&#x3D;2时，子串aba被访问了两次。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>下面来看Manacher算法的改进：</p>
<h5 id="（1）解决长度奇偶性带来的对称中心问题"><a href="#（1）解决长度奇偶性带来的对称中心问题" class="headerlink" title="（1）解决长度奇偶性带来的对称中心问题"></a>（1）解决长度奇偶性带来的对称中心问题</h5><p>Manacher算法对字符串进行了预处理，在所有字符中间插入字符串中未出现过得字符。通过这种方式，所有的回文子串的长度都是奇数长度的。可证明，一定不存在偶数的回文子串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aba  &#x3D;&gt; #a#b#a#</span><br><span class="line">abba &#x3D;&gt; #a#b#b#a#</span><br></pre></td></tr></table></figure>

<h5 id="（2）-解决中心扩展出现的重复检查问题"><a href="#（2）-解决中心扩展出现的重复检查问题" class="headerlink" title="（2） 解决中心扩展出现的重复检查问题"></a>（2） 解决中心扩展出现的重复检查问题</h5><p>当进行遍历的途中，可以根据以下分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 0 1 2 3 4 5 6 7 8 9</span><br><span class="line">假设当前的扩散中心是 6,而且0-5已经检查完毕,0-5的为中心的最大回文串长度已经确定。</span><br><span class="line">此时，如果 以4为中心的最大回文串是: 12345678;</span><br><span class="line">	 那么 6的回文子串在&lt;8的范围内理应和 6关于4对称的2中心所构成的部分子串是相同的。</span><br><span class="line">通过以上的推论：</span><br><span class="line">	1. 当检查某个中心是，尽可能找到之前对称的部分子串，减少枚举长度。</span><br><span class="line">	2. 为了然能找到的子串尽可能的大，需要维护一个所有中心最大回文子串所能到达的最右端点。</span><br></pre></td></tr></table></figure>

<p>为了更好的实现算法，需要引入以下概念：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回文半径：一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径</span><br><span class="line">例如：</span><br><span class="line">	S: # a # b # a #</span><br><span class="line">	p: 1 2 1 4 1 2 1</span><br><span class="line">  p-1: 0 1 0 3 0 1 0</span><br><span class="line">    i: 0 1 2 3 4 5 6</span><br><span class="line">而且，p-1的最大值，恰好就是原字符串回文子串的最大长度。</span><br></pre></td></tr></table></figure>

<p>根据上述的两点：求最长回文子串，那就是求这个回文半径数组；而且，当我们想要求i位置的p[i]时，按照如上分析，可以利用p[0-i-1]的数据减少运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">manacher</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    String sMan = manacherPrepare(s);</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[sMan.length()];</span><br><span class="line">    <span class="keyword">int</span> maxRight = <span class="number">0</span>,pos = <span class="number">0</span>,maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sMan.length();i++)&#123;</span><br><span class="line">        p[i] = i&lt;maxRight ? Math.min(p[<span class="number">2</span>*pos-i],maxRight-i):<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i-p[i]&gt;=<span class="number">0</span> &amp;&amp; i+p[i]&lt;sMan.length() &amp;&amp; sMan.charAt(i-p[i])==sMan.charAt(i+p[i]))&#123;</span><br><span class="line">            p[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[i]+i-<span class="number">1</span> &gt; maxRight)&#123;</span><br><span class="line">            maxRight = p[i] + i -<span class="number">1</span>;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(maxLen,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">manacherPrepare</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">        sb.append(<span class="string">'#'</span>);</span><br><span class="line">        sb.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(<span class="string">'#'</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记之快速幂</title>
    <url>/2020/08/08/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<h3 id="算法笔记之快速幂"><a href="#算法笔记之快速幂" class="headerlink" title="算法笔记之快速幂"></a>算法笔记之快速幂</h3><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题描述:求A^B的最后三位数，并输出。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h5 id="看到这道题目，最简单的思想就是求幂之后取余，代码如下："><a href="#看到这道题目，最简单的思想就是求幂之后取余，代码如下：" class="headerlink" title="看到这道题目，最简单的思想就是求幂之后取余，代码如下："></a>看到这道题目，最简单的思想就是求幂之后取余，代码如下：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Pow_1</span><span class="params">(<span class="keyword">long</span> base,<span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=power;i++)&#123;</span><br><span class="line">        res = res*base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="以上代码无法解决超大指数的情况，也就是x的增长，pow-base-x-会呈现爆炸性增长。"><a href="#以上代码无法解决超大指数的情况，也就是x的增长，pow-base-x-会呈现爆炸性增长。" class="headerlink" title="以上代码无法解决超大指数的情况，也就是x的增长，pow(base,x)会呈现爆炸性增长。"></a>以上代码无法解决超大指数的情况，也就是x的增长，pow(base,x)会呈现爆炸性增长。</h5><h5 id="而且long是64位，所以res在指数很大的情况下会发生溢出。解决方案也很简单，每次结果取余。"><a href="#而且long是64位，所以res在指数很大的情况下会发生溢出。解决方案也很简单，每次结果取余。" class="headerlink" title="而且long是64位，所以res在指数很大的情况下会发生溢出。解决方案也很简单，每次结果取余。"></a>而且long是64位，所以res在指数很大的情况下会发生溢出。解决方案也很简单，每次结果取余。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Pow_2</span><span class="params">(<span class="keyword">long</span> base,<span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=power;i++)&#123;</span><br><span class="line">        res %= <span class="number">1000</span>;</span><br><span class="line">        res = res*base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="目前这种方法就可以很好的解决问题了，但是当前的算法时间复杂度是O-n-如果是power的大小时1e9甚至更大，程序的表现并不好。其实，完全有比进行n次乘法更高效的方法。接下来就是快速幂的方法介绍。"><a href="#目前这种方法就可以很好的解决问题了，但是当前的算法时间复杂度是O-n-如果是power的大小时1e9甚至更大，程序的表现并不好。其实，完全有比进行n次乘法更高效的方法。接下来就是快速幂的方法介绍。" class="headerlink" title="目前这种方法就可以很好的解决问题了，但是当前的算法时间复杂度是O(n).如果是power的大小时1e9甚至更大，程序的表现并不好。其实，完全有比进行n次乘法更高效的方法。接下来就是快速幂的方法介绍。"></a>目前这种方法就可以很好的解决问题了，但是当前的算法时间复杂度是O(n).如果是power的大小时1e9甚至更大，程序的表现并不好。其实，完全有比进行n次乘法更高效的方法。接下来就是快速幂的方法介绍。</h5><h4 id="快速幂方法"><a href="#快速幂方法" class="headerlink" title="快速幂方法"></a>快速幂方法</h4><h5 id="快速幂，顾名思义就是更快速的实现幂的计算。传统计算幂的算法时间复杂度这么高-相对来说），是因为指数为n，就要做n次运算。但是，根据如下推导："><a href="#快速幂，顾名思义就是更快速的实现幂的计算。传统计算幂的算法时间复杂度这么高-相对来说），是因为指数为n，就要做n次运算。但是，根据如下推导：" class="headerlink" title="快速幂，顾名思义就是更快速的实现幂的计算。传统计算幂的算法时间复杂度这么高(相对来说），是因为指数为n，就要做n次运算。但是，根据如下推导："></a>快速幂，顾名思义就是更快速的实现幂的计算。传统计算幂的算法时间复杂度这么高(相对来说），是因为指数为n，就要做n次运算。但是，根据如下推导：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5^10 &#x3D; (25)^5 &#x3D; (625)^2*25</span><br><span class="line">正如的例子:如果求n^k,那么当k为偶数时,n^k &#x3D; (n*n)^(k&#x2F;2);</span><br><span class="line">		   当k为奇数时，n^k &#x3D; (n*n)^(k&#x2F;2)*n;</span><br><span class="line">只要把底数变为原来的平方，指数就缩减为了原来的一半。</span><br><span class="line">那么，我们对底数每次都取平方，那么指数会一直缩减一半，当指数缩小为1，底数就是当前的结果。</span><br></pre></td></tr></table></figure>

<h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Pow_3</span><span class="params">(<span class="keyword">long</span> base,<span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (power&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((res&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">            res = (res*base)%<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        base =(base*base)%<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实际上，快速幂就是尽可能的复用之前的运算结果，时间复杂度为O-logn"><a href="#实际上，快速幂就是尽可能的复用之前的运算结果，时间复杂度为O-logn" class="headerlink" title="实际上，快速幂就是尽可能的复用之前的运算结果，时间复杂度为O(logn)."></a>实际上，快速幂就是尽可能的复用之前的运算结果，时间复杂度为O(logn).</h5>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记之每周刷题整理</title>
    <url>/2021/05/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="本周关键词：状态压缩DP，树状数组，归并排序，拓扑排序。"><a href="#本周关键词：状态压缩DP，树状数组，归并排序，拓扑排序。" class="headerlink" title="本周关键词：状态压缩DP，树状数组，归并排序，拓扑排序。"></a>本周关键词：状态压缩DP，树状数组，归并排序，拓扑排序。</h3><h4 id="题目一：完成所有工作的最短时间-hrad"><a href="#题目一：完成所有工作的最短时间-hrad" class="headerlink" title="题目一：完成所有工作的最短时间 hrad"></a>题目一：<a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/" target="_blank" rel="noopener">完成所有工作的最短时间</a> hrad</h4><h4 id="方法一：状压DP"><a href="#方法一：状压DP" class="headerlink" title="方法一：状压DP"></a>方法一：状压DP</h4><p>n个工作分配给k个工人，求让每个工人的最大工作时长最小。观察数据范围：k,n (1~12),考虑状态压缩。枚举出n种工作的所有分配状态。</p>
<p>设dp[i][j]表示i个工人分配了j状态工作的最大时长，j用来表示状态。那么Dij= min(max(dp[i][k],max(j-k))) k表示所有j的子集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(<span class="keyword">int</span>[] jobs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = jobs.lenth;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = Integer.numberOfTrailingZeros(i),x = i^(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">        sum[i] = sum[x] + jobs[j];</span><br><span class="line">        dp[<span class="number">0</span>][i] = sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxn = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k!=<span class="number">0</span>;k=(k-<span class="number">1</span>)&amp;j) &#123;</span><br><span class="line">                maxn = Math.min(maxn,Math.Max(sum[k],dp[i-<span class="number">1</span>][j-k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="题目二：-最长递增子序列-mid"><a href="#题目二：-最长递增子序列-mid" class="headerlink" title="题目二： 最长递增子序列 mid"></a>题目二： <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长递增子序列</a> mid</h4><p>求数组中严格递增的最长子序列长度</p>
<h4 id="方法一：-暴力DP"><a href="#方法一：-暴力DP" class="headerlink" title="方法一： 暴力DP"></a>方法一： 暴力DP</h4><ul>
<li>时间复杂度 O(n^2)</li>
<li>空间复杂度  O(n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = num.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : dp) res = Math.max(num,res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：-DP-二分"><a href="#方法二：-DP-二分" class="headerlink" title="方法二： DP+二分"></a>方法二： DP+二分</h4><p>更改状态定义，dp[i]表示的是长度为i的递增子序列的最小结尾，那么根据贪心性，如果dp[i]越小，那么后续可能的递增序列越长，起码不会短。同时可以保证dp一定是递增的。如果dp[i]==5,dp[i-1]==7,那么长度为i的递增序列的最大值为5，一定存在i-1序列的最大值&lt;5,故dp[i-1]&lt;7;</p>
<p>那么，遍历nums，在dp中找到dp[i-1]&lt;nums[k]&lt;dp[i]，那么dp[i] = nums[k],此过程可以二分法加速。</p>
<ul>
<li>时间复杂度：O(nLogn)</li>
<li>空间复杂度：O(n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; dp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dp.add(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;dp.get(dp.size()-<span class="number">1</span>)) &#123;</span><br><span class="line">                dp.add(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp.set(bitSearch(dp,nums[i]),nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(dp.toString());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitSearch</span><span class="params">(List&lt;Integer&gt; dp,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = dp.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (i+j)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp.get(mid)==k) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(dp.get(mid)&gt;k)&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                j = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目三-递增的三元子序列-mid"><a href="#题目三-递增的三元子序列-mid" class="headerlink" title="题目三: 递增的三元子序列 mid"></a>题目三: <a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">递增的三元子序列</a> mid</h4><h4 id="解法一-DP"><a href="#解法一-DP" class="headerlink" title="解法一: DP"></a>解法一: DP</h4><p>与最长递增子序列求解一致，只不过此时只需保证dp的长度&gt;=3即可。</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        dp = [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &gt; dp[<span class="number">-1</span>]: </span><br><span class="line">                dp.append(num)</span><br><span class="line">                <span class="keyword">if</span> len(dp)&gt;=<span class="number">3</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">                    <span class="keyword">if</span> dp[i]&gt;=num:</span><br><span class="line">                        dp[i] = num</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="题目四：矩阵中的最长递增路径-hard"><a href="#题目四：矩阵中的最长递增路径-hard" class="headerlink" title="题目四：矩阵中的最长递增路径 hard"></a>题目四：<a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">矩阵中的最长递增路径</a> hard</h4><h4 id="解法一：拓扑排序-DP"><a href="#解法一：拓扑排序-DP" class="headerlink" title="解法一：拓扑排序+DP"></a>解法一：拓扑排序+DP</h4><p>矩阵点之间的最长递增可以抽象成：值小的点对于值大的点有一条有向边。整个矩阵可以抽象成一个有向图，同时递增是单向的，所以最后图是有向无环图。所以可以通过拓扑排序获得线程序列，更具线性序列进行DP。</p>
<ul>
<li>时间复杂度： O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; topo = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// topo</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i+dx[k], y = j+dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x&gt;=<span class="number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n &amp;&amp; matrix[i][j] &gt; matrix[x][y]) inDegree[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[i][j]==<span class="number">0</span>) queue.offerLast(i*n+j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Integer top = queue.pollFirst();</span><br><span class="line">            topo.add(top);</span><br><span class="line">            <span class="keyword">int</span> i = top/n, j = top%n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = i+dx[k], y = j+dy[k];</span><br><span class="line">                <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n &amp;&amp; matrix[x][y] &gt; matrix[i][j]) &#123;</span><br><span class="line">                    inDegree[x][y]--;</span><br><span class="line">                    <span class="keyword">if</span>(inDegree[x][y] == <span class="number">0</span>) queue.offerLast(x*n+y);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n*m];</span><br><span class="line">        <span class="comment">//Arrays.fill(dp,1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=topo.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> point = topo.get(i);</span><br><span class="line">            <span class="keyword">int</span> u = point/n, v = point%n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = u+dx[k], y = v+dy[k];</span><br><span class="line">                <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n &amp;&amp; matrix[u][v] &lt; matrix[x][y]) dp[point] = Math.max(dp[point],dp[x*n+y]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[point]+=<span class="number">1</span>;</span><br><span class="line">            res = Math.max(res,dp[point]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目五：停在原地的方案数-hard"><a href="#题目五：停在原地的方案数-hard" class="headerlink" title="题目五：停在原地的方案数 hard"></a>题目五：<a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">停在原地的方案数</a> hard</h4><h4 id="解法一：2dDP"><a href="#解法一：2dDP" class="headerlink" title="解法一：2dDP"></a>解法一：2dDP</h4><p>盲目dfs本题会超时，考虑：k步走到i=0的位置可以由k-1步走到i=1位置的方案数量获得，dp[i][j] = dp[i-1][j+1]+dp[i-1][j-1]</p>
<ul>
<li>时间复杂度：O(n*k)</li>
<li>空间复杂度：O(n**2)/O(N)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>状态压缩DP，二维DP，树状数组，归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之七大设计原则</title>
    <url>/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h4 id="设计模式之七大设计原则"><a href="#设计模式之七大设计原则" class="headerlink" title="设计模式之七大设计原则"></a>设计模式之七大设计原则</h4><ol>
<li>重用性</li>
<li>可读性(编程规范性)</li>
<li>可扩展性</li>
<li>可靠性</li>
<li><strong>高内聚，低耦合</strong></li>
</ol>
<a id="more"></a>

<h5 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h5><p>描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对类来说，一个类应该只负责一项职责。</span><br></pre></td></tr></table></figure>

<h5 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h5><p>描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</span><br></pre></td></tr></table></figure>

<h5 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h5><p>描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 高层模块不应该依赖底层模块，二者都应该依赖其抽象</span><br><span class="line">2. 抽象不应该依赖细节，细节应该依赖抽象</span><br><span class="line">3. 依赖倒置的中心思想是面向接口编程</span><br></pre></td></tr></table></figure>

<p>实现依赖的三种方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 通过接口传递实现依赖</span><br><span class="line">2. 通过构造方法实现依赖</span><br><span class="line">3. 通过setter方法实现依赖</span><br></pre></td></tr></table></figure>

<h5 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h5><p>描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引用基类的地方必须能透明的使用其子类的对象</span><br><span class="line">使用继承时，根据里氏替换原则，尽量不要重写父类方法</span><br></pre></td></tr></table></figure>

<h5 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h5><p>描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对扩展开放，对修改关闭。</span><br><span class="line">用抽象构建框架，用实现扩展细节。</span><br></pre></td></tr></table></figure>

<h5 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h5><p>描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 迪米特法则(最少知道原则),一个类对自己依赖的类知道的越少越好。</span><br><span class="line">2. 类和类之间的关系越密切，耦合度越大。</span><br></pre></td></tr></table></figure>

<h5 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h5><p>描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">尽量使用合成&#x2F;聚合的方式，而不是继承。</span><br></pre></td></tr></table></figure>

<h5 id="总结：设计原则的核心思想"><a href="#总结：设计原则的核心思想" class="headerlink" title="总结：设计原则的核心思想"></a>总结：设计原则的核心思想</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 找出应用中的可能变化之处，把他们独立出来</span><br><span class="line">2. 针对接口编程，而不是针对实现编程</span><br><span class="line">3. 为了交互对象的松耦合设计而努力</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之死锁</title>
    <url>/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h3 id="操作系统之死锁"><a href="#操作系统之死锁" class="headerlink" title="操作系统之死锁"></a>操作系统之死锁</h3><ul>
<li><h4 id="什么是死锁-Deadlock"><a href="#什么是死锁-Deadlock" class="headerlink" title="什么是死锁(Deadlock)"></a>什么是死锁(Deadlock)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者相互通信而造成的一种阻塞的现象。</span><br><span class="line">若无外力推动，它们都无法进行下去。</span><br><span class="line">此时系统处于了死锁的状态或产生了死锁。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h6 id="举个例子：去食堂打饭，所有人只有同时拥有饭勺和饭碗才能进行打饭，现在假设只有一套饭勺和饭碗。如果进程A获得了饭勺，进程B获得了饭碗。那么A等待获得B的饭碗，而B等待A的饭勺。两个进程无休止的等待，进入了死锁状态。"><a href="#举个例子：去食堂打饭，所有人只有同时拥有饭勺和饭碗才能进行打饭，现在假设只有一套饭勺和饭碗。如果进程A获得了饭勺，进程B获得了饭碗。那么A等待获得B的饭碗，而B等待A的饭勺。两个进程无休止的等待，进入了死锁状态。" class="headerlink" title="举个例子：去食堂打饭，所有人只有同时拥有饭勺和饭碗才能进行打饭，现在假设只有一套饭勺和饭碗。如果进程A获得了饭勺，进程B获得了饭碗。那么A等待获得B的饭碗，而B等待A的饭勺。两个进程无休止的等待，进入了死锁状态。"></a>举个例子：去食堂打饭，所有人只有同时拥有饭勺和饭碗才能进行打饭，现在假设只有一套饭勺和饭碗。如果进程A获得了饭勺，进程B获得了饭碗。那么A等待获得B的饭碗，而B等待A的饭勺。两个进程无休止的等待，进入了死锁状态。</h6></li>
<li><h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><h5 id="死锁的产生必须具备以下四个条件："><a href="#死锁的产生必须具备以下四个条件：" class="headerlink" title="死锁的产生必须具备以下四个条件："></a>死锁的产生必须具备以下四个条件：</h5><ul>
<li><h5 id="互斥条件-mutual-exclusion"><a href="#互斥条件-mutual-exclusion" class="headerlink" title="互斥条件(mutual exclusion)"></a>互斥条件(mutual exclusion)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。</span><br><span class="line">如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</span><br></pre></td></tr></table></figure>

<p>例子中的饭勺和饭碗是竞争的资源，每个饭碗和饭勺在同一时间内只能一个人使用，如果可以同时使用，竞争的条件就不存在了，竞争都不存在，更不会出现死锁了。</p>
</li>
<li><h5 id="请求和保持条件-hold-and-wait"><a href="#请求和保持条件-hold-and-wait" class="headerlink" title="请求和保持条件(hold and wait)"></a>请求和保持条件(hold and wait)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有；</span><br><span class="line">此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</span><br></pre></td></tr></table></figure>

<p>对于所有去打饭的进程，比如作为饭勺的获得者，拿到了饭勺，那么会一直等待饭碗(阻塞)，但是不会主动放弃饭勺。如果可以主动放弃了饭勺，那么又可以继续推动了。</p>
</li>
<li><h5 id="不剥夺条件-no-preemption"><a href="#不剥夺条件-no-preemption" class="headerlink" title="不剥夺条件(no preemption)"></a>不剥夺条件(no preemption)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</span><br></pre></td></tr></table></figure>

<p>作为一个资源的持有者，一个进程占据了饭碗，别的进程想要饭碗的时候，虽然占据饭碗的进程还在等待，但是别的进程不可以来抢我的饭碗(笑。就是资源一旦获得，除非使用结束，不能被剥夺。</p>
</li>
<li><h5 id="环路等待-circular-waiting"><a href="#环路等待-circular-waiting" class="headerlink" title="环路等待(circular waiting)"></a>环路等待(circular waiting)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合&#123;P0，P1，P2，···，Pn&#125;中的P0正在等待一个P1占用的资源；</span><br><span class="line">P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</span><br></pre></td></tr></table></figure>

<p>死锁的出现，一定存在循环依赖。勺与碗的例子中就是一个环，A-&gt;B的碗，B-&gt;A的勺。</p>
</li>
</ul>
</li>
<li><h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h4><h5 id="死锁的产生依赖以上四个必要条件，那么要达到预防死锁的目的，只需要破坏这四个条件之一即可。"><a href="#死锁的产生依赖以上四个必要条件，那么要达到预防死锁的目的，只需要破坏这四个条件之一即可。" class="headerlink" title="死锁的产生依赖以上四个必要条件，那么要达到预防死锁的目的，只需要破坏这四个条件之一即可。"></a>死锁的产生依赖以上四个必要条件，那么要达到预防死锁的目的，只需要破坏这四个条件之一即可。</h5><ul>
<li><h5 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h5><p><strong>方法：</strong>如果允许系统资源都能共享使用，则系统不会进入死锁状态。</p>
<p><strong>缺点：</strong>基本不可能实现，某些资源只能互斥的使用，而且有时还应保护互斥性。</p>
</li>
<li><h5 id="破坏请求与保持条件"><a href="#破坏请求与保持条件" class="headerlink" title="破坏请求与保持条件"></a>破坏请求与保持条件</h5><p><strong>方法：</strong>釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。</p>
<p><strong>缺点：</strong>系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p>
</li>
<li><h5 id="破坏不可剥夺条件"><a href="#破坏不可剥夺条件" class="headerlink" title="破坏不可剥夺条件"></a>破坏不可剥夺条件</h5><p><strong>方法：</strong>当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。</p>
<p><strong>缺点：</strong>该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。</p>
</li>
<li><h5 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h5><p><strong>方法：</strong>可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。</p>
<p><strong>缺点：</strong> 这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。</p>
</li>
</ul>
</li>
<li><h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h4><h5 id="在进行系统资源分配之前，先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配；否则，让进程等待。"><a href="#在进行系统资源分配之前，先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配；否则，让进程等待。" class="headerlink" title="在进行系统资源分配之前，先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配；否则，让进程等待。"></a>在进行系统资源分配之前，先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配；否则，让进程等待。</h5><h5 id="Dijkstra-的银行家算法是避免死锁最具有代表性的算法。起这样的名字是由于该算法原本是为银行系统设计的。以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。在OS中也可以用它来实现避免死锁。"><a href="#Dijkstra-的银行家算法是避免死锁最具有代表性的算法。起这样的名字是由于该算法原本是为银行系统设计的。以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。在OS中也可以用它来实现避免死锁。" class="headerlink" title="Dijkstra 的银行家算法是避免死锁最具有代表性的算法。起这样的名字是由于该算法原本是为银行系统设计的。以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。在OS中也可以用它来实现避免死锁。"></a>Dijkstra 的银行家算法是避免死锁最具有代表性的算法。起这样的名字是由于该算法原本是为银行系统设计的。以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。在OS中也可以用它来实现避免死锁。</h5><p>未完待续……..ing</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>System</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记之二分法解决极小化极大</title>
    <url>/2020/08/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E5%88%86%E6%B3%95%E8%A7%A3%E5%86%B3%E6%9E%81%E5%B0%8F%E5%8C%96%E6%9E%81%E5%A4%A7/</url>
    <content><![CDATA[<h3 id="算法笔记之二分法解决极小化极大"><a href="#算法笔记之二分法解决极小化极大" class="headerlink" title="算法笔记之二分法解决极小化极大"></a>算法笔记之二分法解决极小化极大</h3><h4 id="问题引入："><a href="#问题引入：" class="headerlink" title="问题引入："></a>问题引入：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。</span><br><span class="line">已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。</span><br><span class="line">给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。</span><br><span class="line">n &#x3D;&#x3D; position.length</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; position[i] &lt;&#x3D; 10^9</span><br><span class="line">所有 position 中的整数 互不相同 。</span><br><span class="line">2 &lt;&#x3D; m &lt;&#x3D; position.length</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><blockquote>
<p>题目要求返回最大化的最小磁力，这是这类问题的一个典型的<strong>标志</strong>。</p>
<p>正向分析题目，很难去解决。利用动态规划，贪心还是DFS都很棘手。</p>
<p>但是，这个时候反过来从结果出发，能不能枚举所有可能的最小磁力获得最大的磁力呢？</p>
<p>枚举是可以实现的，以为最小磁力可能出现的区间就是1到数组间隔最大值。</p>
<p>同时，结果的集合又呈单调性。在某个临界点之前都符合题意，之后的所有可能都不符合。</p>
<p>对于这种单调性的问题，二分法就是很好的解决方案了。</p>
<p><strong>结论:从结果出发，二分搜索结果。见到极小化极大，极大化极小的问题，就可以考虑二分法</strong></p>
</blockquote>
<h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ol>
<li>根据题目的数据范围，二分法搜索的区间是<strong>[0,pos[n]-pos[0]]</strong>;</li>
<li>二分法的关键就是如何判定某个点是符合的：设k为某个最小的磁力，那么看数组上以k为距离可以放置多少小球，个数&gt;m成立。</li>
<li>二分法另外一个复杂的点在于边界控制问题。</li>
</ol>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxMinDist</span><span class="params">(<span class="keyword">int</span>[] position,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    Arrays.sort(position);</span><br><span class="line">    <span class="keyword">int</span> n = position.length;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=position[n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(checkMid(mid,n,m,position))&#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkMid</span><span class="params">(<span class="keyword">int</span> mid,<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span>[] position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>,temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(position[i]-position[temp]&gt;=mid)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            temp=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&gt;=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2020/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h3><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><pre><code>&gt; 确保一个类只有一个实例，并提供一个类的全局访问点。</code></pre><hr>
<a id="more"></a>
<h5 id="实现一"><a href="#实现一" class="headerlink" title="实现一:"></a>实现一:</h5><pre><code>&gt; 饿汉式
&gt;
&gt; 类加载到内存后就实例化一个单例,通过JVM保证了线程安全,简单实用.
&gt;
&gt; 缺点:无论单例是否被使用,类加载时就会被实例化(......吹毛求疵)</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sgt01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sgt01 INSTENCE = <span class="keyword">new</span> Sgt01();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">Sgt01</span><span class="params">()</span> </span>&#123; <span class="comment">// 将构造方法定义为private,杜绝new.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sgt01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h5><pre><code>&gt; 懒汉式
&gt;
&gt; 实现了使用时才创建的要求
&gt;
&gt; 但是线程不安全</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sgt02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Sgt02 INSTENCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sgt02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sgt02 <span class="title">getInstence</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTENCE==<span class="keyword">null</span>)&#123;</span><br><span class="line">            INSTENCE = <span class="keyword">new</span> Sgt02();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现三"><a href="#实现三" class="headerlink" title="实现三"></a>实现三</h5><pre><code>&gt; 懒汉式加锁
&gt;
&gt; 解决了线程安全,但是效率变低</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sgt03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Sgt03 INSTENCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sgt03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Sgt03 <span class="title">getInstence</span><span class="params">()</span></span>&#123; <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">if</span>(INSTENCE==<span class="keyword">null</span>)&#123;</span><br><span class="line">            INSTENCE = <span class="keyword">new</span> Sgt03();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现四"><a href="#实现四" class="headerlink" title="实现四"></a>实现四</h5><pre><code>&gt; 双重检查式
&gt;
&gt; 尽可能的提升了加锁之后的效率</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sgt04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Sgt04 INSTENCE; <span class="comment">//加入volatile防止JVM指令重排</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sgt04</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Sgt04 <span class="title">getInstence</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTENCE==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//双重检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Sgt04<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTENCE==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    INSTENCE = <span class="keyword">new</span> Sgt04();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现五"><a href="#实现五" class="headerlink" title="实现五"></a>实现五</h5><pre><code>&gt; 静态内部类
&gt;
&gt; 原理: 虚拟机在加载外部类时候不会加载内部类,只有用到是才加载,实现了懒加载
&gt;
&gt; 线程安全的,和饿汉式一样,是JVM保证的线程安全</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sgt05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sgt05</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sgt05Holder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Sgt05 INSTENCE = <span class="keyword">new</span> Sgt05();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sgt05 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sgt05Holder.INSTENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现六"><a href="#实现六" class="headerlink" title="实现六"></a>实现六</h5><pre><code>&gt; 枚举单例
&gt;
&gt; 不仅可以枚举单例还可以防止反序列化。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  Sgt06 &#123;</span><br><span class="line">    </span><br><span class="line">    INSTENCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/2020/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="设计模式之代理模式"><a href="#设计模式之代理模式" class="headerlink" title="设计模式之代理模式"></a>设计模式之代理模式</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</span><br><span class="line">通俗的讲，就是本来是调用者和被调用者之间的直接交互，现在把调用者和被调用者分离，由代理来负责和调用者之间交互。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h5 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前实现了一个Tank类，Tank类实现了Movable接口，Movable接口定义了一个方法run();</span><br><span class="line">调用Tank类实现的run方法，坦克会run,&quot;Tank moving&quot;.</span><br><span class="line">现在需求是，想要对run方法做一些banchMark性能测试，需要了解run方法的运行时间。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Tank moving..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="源码修改or继承"><a href="#源码修改or继承" class="headerlink" title="源码修改or继承"></a>源码修改or继承</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最为直观也最简单的方式就是直接修改源码，打印运行时间。</span><br><span class="line">问题：缺点也很明显，很多方法的源码并不会暴露。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Tank moving..."</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end-start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">采用继承的方式，构造一个子类继承自Tank来实现计算运行时间。</span><br><span class="line">问题：每新增一个功能就要实现一个子类，实际生产中，新增的需求肯定不止计算时间一种；</span><br><span class="line">	 当多种需求存在时，需要实现多个子类，更不用谈这些功能之间的组合了。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank2</span> <span class="keyword">extends</span> <span class="title">Tank</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代理和被代理对象实现相同的接口，代理的持有该接口类型的字段，字段的值是被代理的对象。</span><br><span class="line">代理实现接口的方法，在增加功能的同时，执行字段中被代理对象的方法。</span><br><span class="line">代理字段类型是接口，同时代理也是接口的实现，可以使得代理直接也可以互相代理。实现功能的组合。</span><br><span class="line">问题：所有的代理只能针对一个接口实现。不能根据传入的对象动态生成代理。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankTimesProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    Movable movable; <span class="comment">//字段持有的是接口  实现既可以被别人代理</span></span><br><span class="line">                    <span class="comment">//也可以代理别的代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankTimesProxy</span><span class="params">(Movable movable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movable = movable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        movable.run();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="动态代理：JDK实现"><a href="#动态代理：JDK实现" class="headerlink" title="动态代理：JDK实现"></a>动态代理：JDK实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动态代理不关心target对象，在运行期间动态的利用反射和ASM生成proxy。</span><br><span class="line">java JDK的reflect包中提供了动态代理生成的解决方案。不需要第三方，功能相对较弱。</span><br><span class="line">问题：所代理的target对象必须实现一个或者多个接口。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Movable proxy = (Movable)Proxy.newProxyInstance(</span><br><span class="line">        Tank<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), </span></span><br><span class="line"><span class="class">        <span class="title">Tank</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), </span></span><br><span class="line"><span class="class">        <span class="title">new</span> <span class="title">LogHandler</span>(<span class="title">new</span> <span class="title">Tank</span>()))</span>;</span><br><span class="line">    proxy.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Tank tank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Tank tank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tank = tank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method:"</span>+method.getName()+<span class="string">" start...."</span>); <span class="comment">//进一步分离代理行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method:"</span>+method.getName()+<span class="string">" end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 其中三个参数，proxy代理对象本身，method被代理对象执行的方法，args方法执行参数</span></span><br><span class="line">        before(method);</span><br><span class="line">        Object o = method.invoke(tank, args);</span><br><span class="line">        end(method);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDK的实现是利用Proxy的newProxyInstance()方法动态创建了Proxy。</span><br><span class="line">此方法传入三个参数，第一个参数是Classloader被代理对象的类加载器；</span><br><span class="line">InterFace[]被代理对象的所有实现接口集合；</span><br><span class="line">以及最后一个InvocationHandler是定制函数执行的处理。</span><br><span class="line">动态代理是通过底层是通过ASM(Java 字节码操控框架,动态生成类或者增强既有类的功能)直接生成的二进制class文件，</span><br><span class="line">可以通过反编译，来了解proxy的构成。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存proxy</span></span><br><span class="line">System.getProperties().put(<span class="string">"jdk.proxy.ProxyGenerator.saveGeneratedFiles"</span>,<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;<span class="comment">//proxy实现了Moveble接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler param1) &#123;</span><br><span class="line">        <span class="comment">//Proxy父类上的字段保存在Proxy.newProxyInstence的第三个参数 InvocationHandler实例</span></span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//代理功能的实现，实际上就是执行了我们自定义的invoke函数</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射获得Method run</span></span><br><span class="line">            m3 = Class.forName(<span class="string">"enplee.DesignPattern.Proxy.V5.Movable"</span>).getMethod(<span class="string">"run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>面试问题之赛马</title>
    <url>/2020/08/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B9%8B%E8%B5%9B%E9%A9%AC/</url>
    <content><![CDATA[<h2 id="面试问题之赛马"><a href="#面试问题之赛马" class="headerlink" title="面试问题之赛马"></a>面试问题之赛马</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote>
<h4 id="一共有64匹赛马，8个赛道，每次比赛获得上赛道的马匹对应的名次，最少需要几次比赛？"><a href="#一共有64匹赛马，8个赛道，每次比赛获得上赛道的马匹对应的名次，最少需要几次比赛？" class="headerlink" title="一共有64匹赛马，8个赛道，每次比赛获得上赛道的马匹对应的名次，最少需要几次比赛？"></a>一共有64匹赛马，8个赛道，每次比赛获得上赛道的马匹对应的名次，最少需要几次比赛？</h4></blockquote>
<a id="more"></a>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><blockquote>
<ol>
<li><p>一次比赛可以获得不多于8数量的有序成绩数组；</p>
</li>
<li><p>首先进行8场比赛，可以获得8组有序的成绩数组；</p>
</li>
<li><p>将8组小组在比赛的第一名，再进行一次比赛，此时进行了9场比赛；</p>
</li>
<li><p>综合以上结果，将8个小组按照第一名排列，获得二维成绩数组。</p>
</li>
<li><p>显然，第一名已经确定，同时可以排除小组第一名成绩在第九次比赛后四名的小组和每组的后四名(因为前四名不可能出现在后四名)。</p>
</li>
<li><p>根据如下数组，可以分别划定2,3,4名的出现范围：</p>
<blockquote>
<p><img src="/.io//.%5C%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B9%8B%E8%B5%9B%E9%A9%AC%5CSaima.png" alt="Saima"></p>
<blockquote>
<p>图中：每列依次排名，由左至右按第一名排名。</p>
<ol>
<li>第一名已经确定，途中黄色所示。</li>
<li>第二名的范围也可确定，途中绿色标识的其中一个</li>
<li>第三名可能的范围是绿色标识和蓝色标识相加。</li>
<li>第四名范围需要讨论?位置的马是否入选第三名(不可能是第二名)，如果蓝色是第三名，那么第四名可能的范围就是绿色+蓝色+粉色+褐色。如果?位置的马不是第三名，第四名的范围就可排除粉色的区域(?的马一定比粉色的快)。</li>
<li>所以，?区域是第三名，9匹候选马，跑两轮；?不是第三名，7匹马，跑一轮。</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><blockquote>
<blockquote>
<p>最多需要跑11轮，最少需要跑10轮。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
